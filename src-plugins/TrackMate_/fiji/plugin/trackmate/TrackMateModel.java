package fiji.plugin.trackmate;

import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.jgrapht.alg.ConnectivityInspector;
import org.jgrapht.event.GraphEdgeChangeEvent;
import org.jgrapht.event.GraphListener;
import org.jgrapht.event.GraphVertexChangeEvent;
import org.jgrapht.graph.DefaultWeightedEdge;
import org.jgrapht.graph.ListenableUndirectedGraph;
import org.jgrapht.graph.SimpleWeightedGraph;
import org.jgrapht.traverse.DepthFirstIterator;

import fiji.plugin.trackmate.features.FeatureModel;

/**
 * <h1>The model for the data managed by TrackMate plugin.</h1>
 * <p>
 * This is a relatively large class, with a lot of public methods. This
 * complexity arose because this class handles data storage and manipulation,
 * through user manual editing and automatic processing. To avoid conflicting
 * accesses to the data, some specialized methods had to be created, hopefully
 * built in coherent sets.
 * 
 * <h2>Main data stored in this model</h2>
 * 
 * We only list here the central fields. This model has other fields, but they
 * are derived from these following 6 fields or used to modify them. These are
 * the only 6 fields that should be written to a file, and they should be enough
 * to fully reconstruct a new model. By processing order, this model stores the
 * following data.
 * 
 * <h3> {@link #settings}</h3>
 * 
 * The {@link Settings} object that determines the behavior of processes,
 * generating the data stored by this model.
 * 
 * <h3>{@link #spots}</h3>
 * 
 * The raw spots generated by the segmentation process, stored as
 * {@link SpotCollection}.
 * 
 * <h3>{@link #initialSpotFilterValue}</h3>
 * 
 * The value of the initial Spot {@link FeatureFilter} on
 * {@link SpotFeature#QUALITY}. Since this filter is constrained to be on
 * quality, and above threshold, we do not store the filter itself (preventing
 * some nasty modifications to be possible), but simply the value of the
 * threshold. That filter will be used to crop the {@link #spots} field: spots
 * with quality lower than this threshold will be removed from the
 * {@link SpotCollection}. They will not be stored, nor saved, nor displayed and
 * their features will not be calculated. This is intended to save computation
 * time only.
 * 
 * <h3>{@link #spotFilters}</h3>
 * 
 * The list of Spot {@link FeatureFilter} that the user can set on any computed
 * feature. It will be used to filter spots and generate the
 * {@link #spotSelection} field, that will be used for tracking.
 * <p>
 * Since it only serves to determine the effect of a process (filtering spots by
 * feature), it logically could be a sub-field of the {@link #settings} object.
 * We found more convenient to have it attached to the model.
 * 
 * <h3>{@link #spotSelection}</h3>
 * 
 * The filtered spot, as a new {@link SpotCollection}. It is important that this
 * collection is made with the same spot objects than for the {@link #spots} field.
 * 
 * <h3>{@link #graph}</h3>
 * 
 * The {@link SimpleWeightedGraph} that contains the map of links between spots.
 * The vertices of the graph are the content of the {@link #spotSelection}
 * field. This is the only convenient way to store links in their more general
 * way we have thought of.
 * <p>
 * It is an undirected graph: we do not indicate the time forward direction
 * using edge direction, but simply refer to the per-frame organization of the
 * {@link SpotCollection}.
 * 
 * <h3>{@link #visibleTrackIndices}</h3>
 * 
 * This Set contains the index of the tracks that are set to be visible. We use this 
 * to flag the tracks that should be retained after filtering the tracks by their
 * features, for instance. Because the user can edit this manually, or because 
 * the track visibility can changed when merging 2 track manually (for instance),
 * we stress on the 'visibility' meaning of this field. 
 * <p>
 * The set contains the indices of the tracks that are visible, in the List
 * of {@link #trackEdges} and {@link #trackSpots}, that are described below.
 * These fields are generated automatically from the track {@link #graph}.
 * For instance, if this set is made of [2, 4], that means the tracks with
 * the indices 2 and 4 in the aforementioned lists are visible, the other not.
 * Of course, {@link TrackMateModelView}s are expected to acknowledge this 
 * content. 
 * <p>
 * This field can be modified publicly using the  {@link #setTrackVisible(Integer, boolean, boolean)}
 * method, or totally overwritten using the {@link #setVisibleTrackIndices(Set, boolean)} method.
 * However, some modifications can arise coming from manual editing of tracks. For instance
 * removing an edge from the middle of a visible tracks generates two new tracks, and
 * possibly shifts the indices of the other tracks. This is hopefully taken care of 
 * the model internal work, and the following rules are implements:
 * <ul>
 * 	<li> TODO
 * </ul>   
 * 
 * <h2>Dependent data</h2>
 * 
 * We list here the fields whose value depends on 
 * 
 * @author Jean-Yves Tinevez <tinevez@pasteur.fr> - 2010-2011
 * 
 */
public class TrackMateModel {

	/*
	 * CONSTANTS
	 */

	private static final boolean DEBUG = false;
	private static final boolean DEBUG_SELECTION = false;

	/*
	 * FIELDS
	 */

	// FEATURES
	
	FeatureModel featureModel;
	
	// SPOTS

	/** Contain the segmentation result, un-filtered. */
	protected SpotCollection spots = new SpotCollection();
	/** Contain the spots retained for tracking, after filtering by features. */
	protected SpotCollection filteredSpots = new SpotCollection();
	/**
	 * The feature filter list that is used to generate {@link #filteredSpots}
	 * from {@link #spots}.
	 */
	protected List<FeatureFilter> spotFilters = new ArrayList<FeatureFilter>();
	/**
	 * The initial quality filter value that is used to clip spots of low
	 * quality from {@link #spots}.
	 */
	protected Float initialSpotFilterValue;

	// TRACKS

	/**
	 * The mother graph, from which all subsequent fields are calculated. This
	 * graph is not made accessible to the outside world. Editing it must be
	 * trough the model methods {@link #addEdge(Spot, Spot, double)},
	 * {@link #removeEdge(DefaultWeightedEdge)}, {@link #removeEdge(Spot, Spot)}
	 * .
	 */
	protected ListenableUndirectedGraph<Spot, DefaultWeightedEdge> graph 
		= new ListenableUndirectedGraph<Spot, DefaultWeightedEdge>(new SimpleWeightedGraph<Spot, DefaultWeightedEdge>(DefaultWeightedEdge.class));
	/** The edges contained in the list of tracks. */
	protected List<Set<DefaultWeightedEdge>> trackEdges = new ArrayList<Set<DefaultWeightedEdge>>();
	/** The spots contained in the list of spots. */
	protected List<Set<Spot>> trackSpots = new ArrayList<Set<Spot>>();
	/** The track filter list that is used to prune track and spots. */
	protected List<FeatureFilter> trackFilters = new ArrayList<FeatureFilter>();
	/**
	 * The visible track indices. Is a set made of the indices of tracks (in
	 * {@link #trackEdges} and {@link #trackSpots}) that are retained after
	 * filtering, and set visible. The user can manually add to or remove from
	 * this list.
	 */
	protected Set<Integer> visibleTrackIndices = new HashSet<Integer>();

	

	// TRANSACTION MODEL

	/**
	 * Counter for the depth of nested transactions. Each call to beginUpdate
	 * increments this counter and each call to endUpdate decrements it. When
	 * the counter reaches 0, the transaction is closed and the respective
	 * events are fired. Initial value is 0.
	 */
	private int updateLevel = 0;
	private List<Spot> spotsAdded = new ArrayList<Spot>();
	private List<Spot> spotsRemoved = new ArrayList<Spot>();
	private List<Spot> spotsMoved = new ArrayList<Spot>();
	private List<Spot> spotsUpdated = new ArrayList<Spot>();
	private List<DefaultWeightedEdge> edgesAdded = new ArrayList<DefaultWeightedEdge>();
	private List<DefaultWeightedEdge> edgesRemoved = new ArrayList<DefaultWeightedEdge>();
	/**
	 * The event cache. During a transaction, some modifications might trigger
	 * the need to fire a model change event. We want to fire these events only
	 * when the transaction closes (when the updayeLevel reaches 0), so we store
	 * the event ID in this cache in the meantime. The event cache contains only
	 * the int IDs of the events listed in {@link TrackMateModelChangeEvent},
	 * namely
	 * <ul>
	 * <li> {@link TrackMateModelChangeEvent#SPOTS_COMPUTED}
	 * <li> {@link TrackMateModelChangeEvent#SPOT_FILTERED}
	 * <li> {@link TrackMateModelChangeEvent#TRACKS_COMPUTED}
	 * <li> {@link TrackMateModelChangeEvent#TRACKS_VISIBILITY_CHANGED}
	 * </ul>
	 * The {@link TrackMateModelChangeEvent#MODEL_MODIFIED} cannot be cached
	 * this way, for it needs to be configured with modification spot and edge
	 * targets, so it uses a different system (see {@link #flushUpdate()}).
	 */
	private HashSet<Integer> eventCache = new HashSet<Integer>();

	// SELECTION

	/** The spot current selection. */
	protected Set<Spot> spotSelection = new HashSet<Spot>();
	/** The edge current selection. */
	protected Set<DefaultWeightedEdge> edgeSelection = new HashSet<DefaultWeightedEdge>();

	// OTHERS

	/** The logger to append processes messages */
	protected Logger logger = Logger.DEFAULT_LOGGER;
	/** The settings that determine processes actions */
	protected Settings settings = new Settings();;

	// LISTENERS

	/**
	 * The list of listeners listening to model content change, that is, changes
	 * in {@link #spots}, {@link #filteredSpots} and {@link #trackGraph}.
	 */
	protected List<TrackMateModelChangeListener> modelChangeListeners = new ArrayList<TrackMateModelChangeListener>();
	/** The list of listener listening to change in selection. */
	protected List<TrackMateSelectionChangeListener> selectionChangeListeners = new ArrayList<TrackMateSelectionChangeListener>();
	





	/*
	 * CONSTRUCTOR
	 */

	public TrackMateModel() {
		graph.addGraphListener(new MyGraphListener());
		featureModel = new FeatureModel(this);
	}









	/*
	 * DEAL WITH MODEL CHANGE LISTENER
	 */

	public void addTrackMateModelChangeListener(TrackMateModelChangeListener listener) {
		modelChangeListeners.add(listener);
	}

	public boolean removeTrackMateModelChangeListener(TrackMateModelChangeListener listener) {
		return modelChangeListeners.remove(listener);
	}

	public List<TrackMateModelChangeListener> getTrackMateModelChangeListener(TrackMateModelChangeListener listener) {
		return modelChangeListeners;
	}

	/*
	 * DEAL WITH SELECTION CHANGE LISTENER
	 */

	public void addTrackMateSelectionChangeListener(TrackMateSelectionChangeListener listener) {
		selectionChangeListeners.add(listener);
	}

	public boolean removeTrackMateSelectionChangeListener(TrackMateSelectionChangeListener listener) {
		return selectionChangeListeners.remove(listener);
	}

	public List<TrackMateSelectionChangeListener> getTrackMateSelectionChangeListener() {
		return selectionChangeListeners;
	}

	/*
	 * DEAL WITH TRACK GRAPH
	 */

	// Questing graph

	/**
	 * Return the number of filtered tracks in the model.
	 */
	public int getNFilteredTracks() {
		if (visibleTrackIndices == null)
			return 0;
		else
			return visibleTrackIndices.size();
	}

	/**
	 * Return the number of <b>un-filtered</b> tracks in the model.
	 */
	public int getNTracks() {
		if (trackSpots == null)
			return 0;
		else
			return trackSpots.size();
	}

	/**
	 * Return the track index of the given edge. Return <code>null</code> if the
	 * edge is not in any track.
	 */
	public Integer getTrackIndexOf(final DefaultWeightedEdge edge) {
		for (int i = 0; i < trackEdges.size(); i++) {
			Set<DefaultWeightedEdge> edges = trackEdges.get(i);
			if (edges.contains(edge)) {
				return i;
			}
		}
		return null;
	}

	/**
	 * Return the track index of the given edge. Return <code>null</code> if the
	 * edge is not in any track.
	 */
	public Integer getTrackIndexOf(final Spot spot) {
		for (int i = 0; i < trackSpots.size(); i++) {
			Set<Spot> edges = trackSpots.get(i);
			if (edges.contains(spot)) {
				return i;
			}
		}
		return null;
	}

	/**
	 * Return true if the track with the given index is within the set of
	 * filtered tracks.
	 */
	public boolean isTrackVisible(final int index) {
		if (visibleTrackIndices.contains(index)) { // work because based on hash
			return true;
		} else {
			return false;
		}

	}

	/**
	 * Return the indices of the tracks that are marked as visible.
	 * 
	 * @see #execTrackFiltering()
	 */
	public Set<Integer> getVisibleTrackIndices() {
		return visibleTrackIndices;
	}

	public Spot getEdgeSource(final DefaultWeightedEdge edge) {
		return graph.getEdgeSource(edge);
	}

	public Spot getEdgeTarget(final DefaultWeightedEdge edge) {
		return graph.getEdgeTarget(edge);
	}

	public double getEdgeWeight(final DefaultWeightedEdge edge) {
		return graph.getEdgeWeight(edge);
	}

	public boolean containsEdge(final Spot source, final Spot target) {
		return graph.containsEdge(source, target);
	}

	public DefaultWeightedEdge getEdge(final Spot source, final Spot target) {
		return graph.getEdge(source, target);
	}

	public Set<DefaultWeightedEdge> edgesOf(final Spot spot) {
		return graph.edgesOf(spot);
	}

	public Set<DefaultWeightedEdge> edgeSet() {
		return graph.edgeSet();
	}

	public DepthFirstIterator<Spot, DefaultWeightedEdge> getDepthFirstIterator(Spot start) {
		return new DepthFirstIterator<Spot, DefaultWeightedEdge>(graph, start);
	}

	public String trackToString(int i) {
		String str = "Track " + i + ": ";
		for (String feature : featureModel.getTrackFeatures())
			str += feature + " = "	+ featureModel.getTrackFeature(i, feature)+ ", ";
				return str;
	}

	

	/*
	 * GRAPH MODIFICATION
	 */

	public void beginUpdate() {
		updateLevel++;
		if (DEBUG)
			System.out.println("[TrackMateModel] #beginUpdate: increasing update level to " + updateLevel + ".");
	}

	public void endUpdate() {
		updateLevel--;
		if (DEBUG)
			System.out.println("[TrackMateModel] #endUpdate: decreasing update level to " + updateLevel + ".");
		if (updateLevel == 0) {
			if (DEBUG)
				System.out.println("[TrackMateModel] #endUpdate: update level is 0, calling flushUpdate().");
			flushUpdate();
		}
	}

	/*
	 * GETTERS / SETTERS
	 */

	public Set<Spot> getTrackSpots(int index) {
		return trackSpots.get(index);
	}

	public Set<DefaultWeightedEdge> getTrackEdges(int index) {
		return trackEdges.get(index);
	}

	/**
	 * Return the <b>un-filtered</b> list of tracks as a list of spots.
	 */
	public List<Set<Spot>> getTrackSpots() {
		return trackSpots;
	}

	/**
	 * Return the <b>un-filtered</b> list of tracks as a list of edges.
	 */
	public List<Set<DefaultWeightedEdge>> getTrackEdges() {
		return trackEdges;
	}

	/**
	 * Return the spots generated by the segmentation part of this plugin. The
	 * collection are un-filtered and contain all spots. They are returned as a
	 * {@link SpotCollection}.
	 */
	public SpotCollection getSpots() {
		return spots;
	}

	/**
	 * Return the spots filtered by feature filters. These spots will be used
	 * for subsequent tracking and display.
	 * <p>
	 * Feature thresholds can be set / added / cleared by
	 * {@link #setSpotFilters(List)}, {@link #addSpotFilter(SpotFilter)} and
	 * {@link #clearSpotFilters()}.
	 */
	public SpotCollection getFilteredSpots() {
		return filteredSpots;
	}

	/**
	 * Overwrite the raw {@link #spots} field, resulting normally from the
	 * {@link #execSegmentation()} process.
	 * 
	 * @param spots
	 * @param doNotify
	 *            if true, will file a
	 *            {@link TrackMateModelChangeEvent#SPOTS_COMPUTED} event.
	 */
	public void setSpots(SpotCollection spots, boolean doNotify) {
		this.spots = spots;
		if (doNotify) {
			final TrackMateModelChangeEvent event = new TrackMateModelChangeEvent(this, TrackMateModelChangeEvent.SPOTS_COMPUTED);
			for (TrackMateModelChangeListener listener : modelChangeListeners)
				listener.modelChanged(event);
		}
	}

	/**
	 * Overwrite the {@link #filteredSpots} field, resulting normally from the
	 * {@link #execSpotFiltering()} process.
	 * 
	 * @param doNotify  if true, will fire a {@link TrackMateModelChangeEvent#SPOTS_FILTERED} event.
	 */
	public void setFilteredSpots(final SpotCollection filteredSpots, boolean doNotify) {
		this.filteredSpots = filteredSpots;
		if (doNotify) {
			final TrackMateModelChangeEvent event = new TrackMateModelChangeEvent(this, TrackMateModelChangeEvent.SPOTS_FILTERED);
			for (TrackMateModelChangeListener listener : modelChangeListeners)
				listener.modelChanged(event);
		}
	}

	/**
	 * Overwrite the {@link #visibleTrackIndices} field, resulting normally from the 
	 * {@link #execTrackFiltering()} process.
	 * 
	 * @param doNotify if true, will fire a {@link TrackMateModelChangeEvent#TRACKS_VISIBILITY_CHANGED} 
	 * event.
	 */
	public void setVisibleTrackIndices(Set<Integer> visibleTrackIndices, boolean doNotify) {
		this.visibleTrackIndices = visibleTrackIndices;
		if (doNotify) {
			final TrackMateModelChangeEvent event = new TrackMateModelChangeEvent(this, TrackMateModelChangeEvent.TRACKS_VISIBILITY_CHANGED);
			for (TrackMateModelChangeListener listener : modelChangeListeners)
				listener.modelChanged(event);
		}
	}

	/**
	 * Change the visibility of a given track, whose index is given. 
	 * 
	 * @param trackIndex  the index of the track whose visibility is to change. If <code>null</code>,
	 * nothing is done.
	 * @param visible  if true, the track will be made visible, and invisible otherwise. If the track
	 * was already visible, or respectively invisible, nothing is done.
	 * @param doNotify  if true, and if some changes occurred, an event with the ID 
	 * {@link TrackMateModelChangeEvent#TRACKS_VISIBILITY_CHANGED} will be fired.
	 * @return  true if and only if the call to this method actually changed the current visible 
	 * settings of tracks.
	 */
	public boolean setTrackVisible(Integer trackIndex, boolean visible, boolean doNotify) {
		if (trackIndex == null)
			return false;

		boolean modified = false;
		if (visible) {
			modified = visibleTrackIndices.add(trackIndex);
		} else {
			modified = visibleTrackIndices.remove(trackIndex);
		}

		if (doNotify && modified) {
			TrackMateModelChangeEvent event = new TrackMateModelChangeEvent(this, TrackMateModelChangeEvent.TRACKS_VISIBILITY_CHANGED);
			for (TrackMateModelChangeListener listener : modelChangeListeners) 
				listener.modelChanged(event);
		}

		return modified;
	}

	/**
	 * Set the graph resulting from the tracking process, and fire a
	 * {@link TrackMateModelChangeEvent#TRACKS_COMPUTED} event. The {@link #visibleTrackIndices}
	 * field is set to make all new tracks visible by default.
	 * <p>
	 * Calling this method <b>overwrites<b> the current graph.
	 */
	public void setGraph(final SimpleWeightedGraph<Spot, DefaultWeightedEdge> graph) {
		this.graph = new ListenableUndirectedGraph<Spot, DefaultWeightedEdge>(graph);
		this.graph.addGraphListener(new MyGraphListener());
		//
		computeTracksFromGraph();
		computeTrackFeatures();
		//
		visibleTrackIndices = new HashSet<Integer>(getNTracks());
		for (int i = 0; i < getNTracks(); i++)
			visibleTrackIndices.add(i);
		//
		final TrackMateModelChangeEvent event = new TrackMateModelChangeEvent(this, TrackMateModelChangeEvent.TRACKS_COMPUTED);
		for (TrackMateModelChangeListener listener : modelChangeListeners)
			listener.modelChanged(event);
	}

	public void clearTracks() {
		this.graph = new ListenableUndirectedGraph<Spot, DefaultWeightedEdge>(
				new SimpleWeightedGraph<Spot, DefaultWeightedEdge>(DefaultWeightedEdge.class));
		this.graph.addGraphListener(new MyGraphListener());
		this.trackEdges = null;
		this.trackSpots = null;
	}

	/*
	 * FEATURE FILTERS
	 */

	/**
	 * Add a filter to the list of spot filters to deal with when executing
	 * {@link #execFiltering()}.
	 */
	public void addSpotFilter(final FeatureFilter filter) {
		spotFilters.add(filter);
	}

	public void removeSpotFilter(final FeatureFilter filter) {
		spotFilters.remove(filter);
	}

	/** Remove all spot filters stored in this model. */
	public void clearSpotFilters() {
		spotFilters.clear();
	}

	public List<FeatureFilter> getSpotFilters() {
		return spotFilters;
	}

	public void setSpotFilters(List<FeatureFilter> spotFilters) {
		this.spotFilters = spotFilters;
	}

	/**
	 * Return the initial filter value on {@link SpotFeature#QUALITY} stored in
	 * this model.
	 */
	public Float getInitialSpotFilterValue() {
		return initialSpotFilterValue;
	}

	/**
	 * Set the initial filter value on {@link SpotFeature#QUALITY} stored in
	 * this model.
	 */
	public void setInitialSpotFilterValue(Float initialSpotFilterValue) {
		this.initialSpotFilterValue = initialSpotFilterValue;
	}

	/** Add a filter to the list of track filters. */
	public void addTrackFilter(final FeatureFilter filter) {
		trackFilters.add(filter);
	}

	public void removeTrackFilter(final FeatureFilter filter) {
		trackFilters.remove(filter);
	}

	/** Remove all track filters stored in this model. */
	public void clearTrackFilters() {
		trackFilters.clear();
	}

	public List<FeatureFilter> getTrackFilters() {
		return trackFilters;
	}

	public void setTrackFilters(List<FeatureFilter> trackFilters) {
		this.trackFilters = trackFilters;
	}

	/*
	 * LOGGER
	 */

	/**
	 * Set the logger that will receive the messages from the processes
	 * occurring within this plugin.
	 */
	public void setLogger(Logger logger) {
		this.logger = logger;
	}

	/**
	 * Return the logger currently set for this model.
	 */
	public Logger getLogger() {
		return logger;
	}

	/*
	 * SETTINGS
	 */

	/**
	 * Return the {@link Settings} object that determines the behavior of this
	 * plugin.
	 */
	public Settings getSettings() {
		return settings;
	}

	/**
	 * Set the {@link Settings} object that determines the behavior of this
	 * model's processes.
	 * 
	 * @see #execSegmentation()
	 * @see #execTracking()
	 */

	public void setSettings(Settings settings) {
		this.settings = settings;
	}

	/*
	 * FEATURES
	 */

	public FeatureModel getFeatureModel() {
		return featureModel;
	}
	
	/*
	 * SELECTION METHODSs
	 */

	public void clearSelection() {
		if (DEBUG_SELECTION)
			System.out.println("[TrackMateModel] Clearing selection");
		// Prepare event
		Map<Spot, Boolean> spotMap = new HashMap<Spot, Boolean>(spotSelection.size());
		for (Spot spot : spotSelection)
			spotMap.put(spot, false);
				Map<DefaultWeightedEdge, Boolean> edgeMap = new HashMap<DefaultWeightedEdge, Boolean>(edgeSelection.size());
				for (DefaultWeightedEdge edge : edgeSelection)
					edgeMap.put(edge, false);
						TrackMateSelectionChangeEvent event = new TrackMateSelectionChangeEvent(this, spotMap, edgeMap);
						// Clear fields
						clearSpotSelection();
						clearEdgeSelection();
						// Fire event
						for (TrackMateSelectionChangeListener listener : selectionChangeListeners)
							listener.selectionChanged(event);
	}

	public void clearSpotSelection() {
		if (DEBUG_SELECTION)
			System.out.println("[TrackMateModel] Clearing spot selection");
		// Prepare event
		Map<Spot, Boolean> spotMap = new HashMap<Spot, Boolean>(spotSelection.size());
		for (Spot spot : spotSelection)
			spotMap.put(spot, false);
				TrackMateSelectionChangeEvent event = new TrackMateSelectionChangeEvent(this, spotMap, null);
				// Clear field
				spotSelection.clear();
				// Fire event
				for (TrackMateSelectionChangeListener listener : selectionChangeListeners)
					listener.selectionChanged(event);
	}

	public void clearEdgeSelection() {
		if (DEBUG_SELECTION)
			System.out.println("[TrackMateModel] Clearing edge selection");
		// Prepare event
		Map<DefaultWeightedEdge, Boolean> edgeMap = new HashMap<DefaultWeightedEdge, Boolean>(edgeSelection.size());
		for (DefaultWeightedEdge edge : edgeSelection)
			edgeMap.put(edge, false);
				TrackMateSelectionChangeEvent event = new TrackMateSelectionChangeEvent(this, null, edgeMap);
				// Clear field
				edgeSelection.clear();
				// Fire event
				for (TrackMateSelectionChangeListener listener : selectionChangeListeners)
					listener.selectionChanged(event);
	}

	public void addSpotToSelection(final Spot spot) {
		if (!spotSelection.add(spot))
			return; // Do nothing if already present in selection
		if (DEBUG_SELECTION)
			System.out.println("[TrackMateModel] Adding spot " + spot + " to selection");
		Map<Spot, Boolean> spotMap = new HashMap<Spot, Boolean>(1);
		spotMap.put(spot, true);
		if (DEBUG_SELECTION)
			System.out.println("[TrackMateModel] Seding event to listeners: "+selectionChangeListeners);
		TrackMateSelectionChangeEvent event = new TrackMateSelectionChangeEvent(this, spotMap, null);
		for (TrackMateSelectionChangeListener listener : selectionChangeListeners)
			listener.selectionChanged(event);
	}

	public void removeSpotFromSelection(final Spot spot) {
		if (!spotSelection.remove(spot))
			return; // Do nothing was not already present in selection
		if (DEBUG_SELECTION)
			System.out.println("[TrackMateModel] Removing spot " + spot + " from selection");
		Map<Spot, Boolean> spotMap = new HashMap<Spot, Boolean>(1);
		spotMap.put(spot, false);
		TrackMateSelectionChangeEvent event = new TrackMateSelectionChangeEvent(this, spotMap, null);
		for (TrackMateSelectionChangeListener listener : selectionChangeListeners)
			listener.selectionChanged(event);
	}

	public void addSpotToSelection(final Collection<Spot> spots) {
		Map<Spot, Boolean> spotMap = new HashMap<Spot, Boolean>(spots.size());
		for (Spot spot : spots) {
			if (spotSelection.add(spot)) {
				spotMap.put(spot, true);
				if (DEBUG_SELECTION)
					System.out.println("[TrackMateModel] Adding spot " + spot + " to selection");
			}
		}
		TrackMateSelectionChangeEvent event = new TrackMateSelectionChangeEvent(this, spotMap, null);
		if (DEBUG_SELECTION) 
			System.out.println("[TrackMateModel] Seding event "+event.hashCode()+" to "+selectionChangeListeners.size()+" listeners: "+selectionChangeListeners);
		for (TrackMateSelectionChangeListener listener : selectionChangeListeners)
			listener.selectionChanged(event);
	}

	public void removeSpotFromSelection(final Collection<Spot> spots) {
		Map<Spot, Boolean> spotMap = new HashMap<Spot, Boolean>(spots.size());
		for (Spot spot : spots) {
			if (spotSelection.remove(spot)) {
				spotMap.put(spot, false);
				if (DEBUG_SELECTION)
					System.out.println("[TrackMateModel] Removing spot " + spot + " from selection");
			}
		}
		TrackMateSelectionChangeEvent event = new TrackMateSelectionChangeEvent(this, spotMap, null);
		for (TrackMateSelectionChangeListener listener : selectionChangeListeners)
			listener.selectionChanged(event);
	}

	public void addEdgeToSelection(final DefaultWeightedEdge edge) {
		if (!edgeSelection.add(edge))
			return; // Do nothing if already present in selection
		if (DEBUG_SELECTION)
			System.out.println("[TrackMateModel] Adding edge " + edge + " to selection");
		Map<DefaultWeightedEdge, Boolean> edgeMap = new HashMap<DefaultWeightedEdge, Boolean>(1);
		edgeMap.put(edge, true);
		TrackMateSelectionChangeEvent event = new TrackMateSelectionChangeEvent(this, null, edgeMap);
		for (TrackMateSelectionChangeListener listener : selectionChangeListeners)
			listener.selectionChanged(event);

	}

	public void removeEdgeFromSelection(final DefaultWeightedEdge edge) {
		if (!edgeSelection.remove(edge))
			return; // Do nothing if already present in selection
		if (DEBUG_SELECTION)
			System.out.println("[TrackMateModel] Removing edge " + edge + " from selection");
		Map<DefaultWeightedEdge, Boolean> edgeMap = new HashMap<DefaultWeightedEdge, Boolean>(1);
		edgeMap.put(edge, false);
		TrackMateSelectionChangeEvent event = new TrackMateSelectionChangeEvent(this, null, edgeMap);
		for (TrackMateSelectionChangeListener listener : selectionChangeListeners)
			listener.selectionChanged(event);

	}

	public void addEdgeToSelection(final Collection<DefaultWeightedEdge> edges) {
		Map<DefaultWeightedEdge, Boolean> edgeMap = new HashMap<DefaultWeightedEdge, Boolean>(edges.size());
		for (DefaultWeightedEdge edge : edges) {
			if (edgeSelection.add(edge)) {
				edgeMap.put(edge, true);
				if (DEBUG_SELECTION)
					System.out.println("[TrackMateModel] Adding edge " + edge + " to selection");
			}
		}
		TrackMateSelectionChangeEvent event = new TrackMateSelectionChangeEvent(this, null, edgeMap);
		for (TrackMateSelectionChangeListener listener : selectionChangeListeners)
			listener.selectionChanged(event);
	}

	public void removeEdgeFromSelection(final Collection<DefaultWeightedEdge> edges) {
		Map<DefaultWeightedEdge, Boolean> edgeMap = new HashMap<DefaultWeightedEdge, Boolean>(edges.size());
		for (DefaultWeightedEdge edge : edges) {
			if (edgeSelection.remove(edge)) {
				edgeMap.put(edge, false);
				if (DEBUG_SELECTION)
					System.out.println("[TrackMateModel] Removing edge " + edge + " from selection");
			}
		}
		TrackMateSelectionChangeEvent event = new TrackMateSelectionChangeEvent(this, null, edgeMap);
		for (TrackMateSelectionChangeListener listener : selectionChangeListeners)
			listener.selectionChanged(event);
	}

	public Set<Spot> getSpotSelection() {
		return spotSelection;
	}

	public Set<DefaultWeightedEdge> getEdgeSelection() {
		return edgeSelection;
	}

	/*
	 * MODEL CHANGE METHODS
	 */

	/**
	 * Move a single spot from a frame to another, then update its features.
	 * 
	 * @param spotToMove
	 *            the spot to move
	 * @param fromFrame
	 *            the frame the spot originated from
	 * @param toFrame
	 *            the destination frame
	 * @param doNotify
	 *            if false, {@link TrackMateModelChangeListener}s will not be
	 *            notified of this change
	 */
	public void moveSpotFrom(Spot spotToMove, Integer fromFrame, Integer toFrame) {
		spots.add(spotToMove, toFrame);
		spots.remove(spotToMove, fromFrame);
		if (DEBUG)
			System.out.println("[TrackMateModel] Moving " + spotToMove + " from frame " + fromFrame + " to frame " + toFrame);

		filteredSpots.add(spotToMove, toFrame);
		filteredSpots.remove(spotToMove, fromFrame);

		spotsMoved.add(spotToMove); // TRANSACTION

	}

	/**
	 * Add a single spot to the collections managed by this model, then update
	 * its features.
	 */
	public void addSpotTo(Spot spotToAdd, Integer toFrame) {
		if (spots.add(spotToAdd, toFrame)) {
			spotsAdded.add(spotToAdd); // TRANSACTION
			if (DEBUG)
				System.out.println("[TrackMateModel] Adding spot " + spotToAdd + " to frame " + toFrame);
		}
		filteredSpots.add(spotToAdd, toFrame);
		graph.addVertex(spotToAdd);

	}

	/**
	 * Remove a single spot from the collections managed by this model.
	 * 
	 * @param fromFrame
	 *            the frame the spot is in, if it is known. If <code>null</code>
	 *            is given, then the adequate frame is retrieved from this
	 *            model's collections.
	 */
	public void removeSpotFrom(final Spot spotToRemove, Integer fromFrame) {
		if (fromFrame == null)
			fromFrame = spots.getFrame(spotToRemove);
		if (spots.remove(spotToRemove, fromFrame)) {
			spotsRemoved.add(spotToRemove); // TRANSACTION
			if (DEBUG)
				System.out.println("[TrackMateModel] Removing spot " + spotToRemove + " from frame " + fromFrame);
		}
		filteredSpots.remove(spotToRemove, fromFrame);
		graph.removeVertex(spotToRemove);
	}

	// Modify graph

	public DefaultWeightedEdge addEdge(final Spot source, final Spot target, final double weight) {
		// Mother graph
		DefaultWeightedEdge edge = graph.addEdge(source, target);
		graph.setEdgeWeight(edge, weight);
		if (DEBUG)
			System.out.println("[TrackMateModel] Adding edge between " + source + " and " + target + " with weight " + weight);
		return edge;
	}

	public DefaultWeightedEdge removeEdge(final Spot source, final Spot target) {
		// Other graph
		DefaultWeightedEdge edge = graph.removeEdge(source, target);
		if (DEBUG)
			System.out.println("[TrackMateModel] Removing edge between " + source + " and " + target);
		return edge;
	}

	public boolean removeEdge(final DefaultWeightedEdge edge) {
		// Mother graph
		boolean removed = graph.removeEdge(edge);
		if (DEBUG)
			System.out.println("[TrackMateModel] Removing edge " + edge + " between " + graph.getEdgeSource(edge) + " and " + graph.getEdgeTarget(edge));
		return removed;
	}

	/**
	 * Set the track with the given index to visible, and fire a
	 * {@link TrackMateModelChangeEvent#TRACKS_VISIBILITY_CHANGED} event at the end of the
	 * transaction.
	 */
	public void addTrackToVisibleList(int trackIndex) {
		boolean added = visibleTrackIndices.add(trackIndex);
		if (added) {
			if (DEBUG) {
				System.out.println("[TrackMateModel] addTrackToVisibleList: added track number "
						+ trackIndex + " to visible list.");
			}
			eventCache.add(TrackMateModelChangeEvent.TRACKS_VISIBILITY_CHANGED);
		}
	}

	/*
	 * MODIFY SPOT FEATURES
	 */

	/**
	 * Do the actual feature update for given spots.
	 */
	private void updateFeatures(final List<Spot> spotsToUpdate) {
		if (DEBUG)
			System.out.println("[TrackMateModel] Updating the features of " + spotsToUpdate.size() + " spots.");

		// Find common frames
		SpotCollection toCompute = filteredSpots.subset(spotsToUpdate);
		featureModel.computeSpotFeatures(toCompute);
	}

	public void updateFeatures(final Spot spotToUpdate) {
		spotsUpdated.add(spotToUpdate); // Enlist for feature update when transaction is marked as finished
	}


	/**
	 * Calculate all features for the tracks in this model.
	 */
	public void computeTrackFeatures() {
		featureModel.computeTrackFeatures();
	}



	/*
	 * PRIVATE METHODS
	 */
	
	
	/**
	 * Fire events. Regenerate fields derived from the filtered graph.
	 */
	private void flushUpdate() {

		if (DEBUG) {
			System.out.println("[TrackMateModel] #flushUpdate().");
			System.out.println("[TrackMateModel] #flushUpdate(): Event cache is :" + eventCache);
		}

		/* We recompute tracks only if some edges have been added or removed,
		 * and if some spots have been removed (equivalent to remove edges). We do
		 * NOT recompute tracks if spots have been added: they will not result in
		 * new tracks made of single spots.	 */

		int nEdgesToSignal = edgesAdded.size() + edgesRemoved.size();
		if (nEdgesToSignal + spotsRemoved.size() > 0) {
			computeTracksFromGraph();
//						new Thread("TrackMate track features computing thread") {
//							public void run() {
//								computeTrackFeatures(); // We do it in a thread because it is a lengthy operation
//							}
//						}.start();
		}

		// Deal with new or moved spots: we need to update their features.
		int nSpotsToUpdate = spotsAdded.size() + spotsMoved.size() + spotsUpdated.size();
		if (nSpotsToUpdate > 0) {
			ArrayList<Spot> spotsToUpdate = new ArrayList<Spot>(nSpotsToUpdate);
			spotsToUpdate.addAll(spotsAdded);
			spotsToUpdate.addAll(spotsMoved);
			spotsToUpdate.addAll(spotsUpdated);
			updateFeatures(spotsToUpdate);
		}

		// Initialize event
		TrackMateModelChangeEvent event = new TrackMateModelChangeEvent(this, TrackMateModelChangeEvent.MODEL_MODIFIED);

		// Configure it with spots to signal.
		int nSpotsToSignal = nSpotsToUpdate + spotsRemoved.size();
		if (nSpotsToSignal > 0) {
			ArrayList<Spot> spotsToSignal = new ArrayList<Spot>(nSpotsToSignal);
			spotsToSignal.addAll(spotsAdded);
			spotsToSignal.addAll(spotsRemoved);
			spotsToSignal.addAll(spotsMoved);
			spotsToSignal.addAll(spotsUpdated);
			ArrayList<Integer> spotsFlag = new ArrayList<Integer>(nSpotsToSignal);
			for (int i = 0; i < spotsAdded.size(); i++)
				spotsFlag.add(TrackMateModelChangeEvent.FLAG_SPOT_ADDED);
			for (int i = 0; i < spotsRemoved.size(); i++)
				spotsFlag.add(TrackMateModelChangeEvent.FLAG_SPOT_REMOVED);
			for (int i = 0; i < spotsMoved.size(); i++)
				spotsFlag.add(TrackMateModelChangeEvent.FLAG_SPOT_FRAME_CHANGED);
			for (int i = 0; i < spotsUpdated.size(); i++)
				spotsFlag.add(TrackMateModelChangeEvent.FLAG_SPOT_MODIFIED);

			event.setSpots(spotsToSignal);
			event.setSpotFlags(spotsFlag);
		}


		// Configure it with edges to signal.
		if (nEdgesToSignal > 0) {
			ArrayList<DefaultWeightedEdge> edgesToSignal = new ArrayList<DefaultWeightedEdge>(nEdgesToSignal);
			edgesToSignal.addAll(edgesAdded);
			edgesToSignal.addAll(edgesRemoved);
			ArrayList<Integer> edgesFlag = new ArrayList<Integer>(nEdgesToSignal);
			for (int i = 0; i < edgesAdded.size(); i++)
				edgesFlag.add(TrackMateModelChangeEvent.FLAG_EDGE_ADDED);
			for (int i = 0; i < edgesRemoved.size(); i++)
				edgesFlag.add(TrackMateModelChangeEvent.FLAG_EDGE_REMOVED);

			event.setEdges(edgesToSignal);
			event.setEdgeFlags(edgesFlag);
		}

		try {
			if (nEdgesToSignal + nSpotsToSignal > 0) {
				if (DEBUG) {
					System.out.println("[TrackMateModel] #flushUpdate(): firing model modified event.");
				}
				for (final TrackMateModelChangeListener listener : modelChangeListeners) {
					listener.modelChanged(event);
				}
			}

			// Fire events stored in the event cache
			for (int eventID : eventCache) {
				if (DEBUG) {
					System.out.println("[TrackMateModel] #flushUpdate(): firing event with ID "	+ eventID);
				}
				TrackMateModelChangeEvent cachedEvent = new TrackMateModelChangeEvent(this, eventID);
				for (final TrackMateModelChangeListener listener : modelChangeListeners) {
					listener.modelChanged(cachedEvent);
				}
			}

		} finally {
			spotsAdded.clear();
			spotsRemoved.clear();
			spotsMoved.clear();
			spotsUpdated.clear();
			edgesAdded.clear();
			edgesRemoved.clear();
			eventCache.clear();
		}

	}

	/**
	 * Compute the two track lists {@link #trackSpots} and {@link #trackSpots}
	 * from the {@link #graph}. These two track lists are the only objects
	 * reflecting the tracks visible from outside the model.
	 * <p>
	 * The guts of this method are a bit convoluted: we must make sure that
	 * tracks that were visible previous to the changes that called for this
	 * method are still visible after, event if some tracks are merge, deleted
	 * or split.
	 */
	private void computeTracksFromGraph() {
		// Retain old values
		List<Set<Spot>> oldTrackSpots = trackSpots;

		// Build new track lists
		this.trackSpots = new ConnectivityInspector<Spot, DefaultWeightedEdge>(graph).connectedSets();
		this.trackEdges = new ArrayList<Set<DefaultWeightedEdge>>(trackSpots.size());

		for (Set<Spot> spotTrack : trackSpots) {
			Set<DefaultWeightedEdge> spotEdge = new HashSet<DefaultWeightedEdge>();
			for (Spot spot : spotTrack) {
				spotEdge.addAll(graph.edgesOf(spot));
			}
			trackEdges.add(spotEdge);
		}

		/* Deal with a special case: of there were no tracks at all before this call,
		 * then oldTrackSpots is null. To avoid that, we set it to the new value. Also,
		 * since the the visibility set is empty, we will not get any new track visible.
		 * So we seed it with all track indices, letting it propagate to new tracks. 
		 * So that manually added track will have a visibility to on.
		 */
		if (oldTrackSpots.isEmpty()) {
			oldTrackSpots = trackSpots;
			for (int i = 0; i < trackSpots.size(); i++) {
				visibleTrackIndices.add(i);
			}
		}

		// Try to infer correct visibility
		final int ntracks = trackSpots.size();
		final int noldtracks = oldTrackSpots.size();
		final Set<Integer> oldTrackVisibility = visibleTrackIndices;
		visibleTrackIndices = new HashSet<Integer>(noldtracks); // Approx
		// How to know if a new track should be visible or not?
		// We can say this: the new track should be visible if it has at least
		// one spot
		// that can be found in a visible old track.
		for (int trackIndex = 0; trackIndex < ntracks; trackIndex++) {

			boolean shouldBeVisible = false;
			for (final Spot spot : trackSpots.get(trackIndex)) {

				for (int oldTrackIndex : oldTrackVisibility) { // we iterate over only old VISIBLE tracks
					if (oldTrackSpots.get(oldTrackIndex).contains(spot)) {
						shouldBeVisible = true;
						break;
					}
				}
				if (shouldBeVisible) {
					break;
				}
			}

			if (shouldBeVisible) {
				visibleTrackIndices.add(trackIndex);
			}

		}
	}

	
	/**
	 * This listener class is made to deal with complex changes in the track graph.
	 * <p>
	 * By complex change, we mean the changes occurring in the graph caused by 
	 * another change that was initiated manually by the user. For instance, imagine
	 * we have a simple track branch made of 5 spots that link linearly, like this:
	 * <pre>
	 * 	S1 - S2 - S3 - S4 - S5
	 * </pre>
	 * The user might want to remove the S3 spot, in the middle of the track. On top
	 * of the track rearrangement, that is dealt with elsewhere in the model 
	 * class, this spot removal also triggers 2 edges removal: the links S2-S3 and S3-S4
	 * disappear. The only way for the {@link TrackMateModel} to be aware of that, 
	 * and to forward these events to its listener, is to listen itself to the
	 * {@link #graph} that store links. 
	 * <p>
	 * This is done through this class. This class is notified every time a change occur in 
	 * the {@link #graph}:
	 * <ul>
	 * 	<li>It ignores events triggered by spots being added
	 * or removed, because they can't be triggered automatically, and are dealt with 
	 * in the {@link TrackMateModel#addSpotTo(Spot, Integer)} and 
	 * {@link TrackMateModel#removeSpotFrom(Spot, Integer)} methods.
	 * 	<li> It catches all events triggered by a link being added or removed in the graph,
	 * whether they are triggered manually through a call to a model method such as 
	 * {@link TrackMateModel#addEdge(Spot, Spot, double)}, or triggered by another call.
	 * They are used to build the {@link TrackMateModel#edgesAdded} and {@link TrackMateModel#edgesRemoved}
	 * fields, that will be used to notify listeners of the model.    
	 * 
	 * @author Jean-Yves Tinevez <jeanyves.tinevez@gmail.com> Aug 12, 2011
	 *
	 */
	private class MyGraphListener implements GraphListener<Spot, DefaultWeightedEdge> {

		@Override
		public void vertexAdded(GraphVertexChangeEvent<Spot> e) {}

		@Override
		public void vertexRemoved(GraphVertexChangeEvent<Spot> e) {}

		@Override
		public void edgeAdded(GraphEdgeChangeEvent<Spot, DefaultWeightedEdge> e) {
			edgesAdded.add(e.getEdge());
		}

		@Override
		public void edgeRemoved(GraphEdgeChangeEvent<Spot, DefaultWeightedEdge> e) {
			edgesRemoved.add(e.getEdge());
		}

	}

}
