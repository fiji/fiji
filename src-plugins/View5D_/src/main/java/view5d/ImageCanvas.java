/****************************************************************************
 *   Copyright (C) 1996-2007 by Rainer Heintzmann                          *
 *   heintzmann@gmail.com                                                  *
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program; if not, write to the                         *
 *   Free Software Foundation, Inc.,                                       *
 *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
 ***************************************************************************
*/
// By making the appropriate class "View5D" or "View5D_" public and renaming the file, this code can be toggled between Applet and ImageJ respectively

// import java.io.*;
package view5d;

import java.awt.image.*;
import java.awt.event.*;
import java.awt.*;
import java.util.*;
import java.text.*;
import ij.gui.*;  // for export of plotwindow

// a canvas represents one view of the data
public class ImageCanvas extends Canvas implements ImageObserver,MouseListener,MouseMotionListener,KeyListener,FocusListener,AdjustmentListener {
    static final long serialVersionUID = 1;
    //int		xadd = 0;
    //int		yadd = 0;
    int		dadd = 0;  // addition parameter in depth for other two canvases; this offset is measured in display pixel coordinates
    int		xprev = 0;
    int		yprev = 0;
    
    int         ROIs;
    int         ROIe;
    boolean     LineROIStarted = false;
    int         LROIs = -1;
    int         LROIe = -1;
    boolean     ROIMoveStarted=false;
    int         ROIMoveStartX;
    int         ROIMoveStartY;
    int         ROIMoveDX=0;
    int         ROIMoveDY=0;
    Polygon tmpROIPolygons=null;   // these are only used before the ROI is saved

    boolean     ImgDragStarted=false; // for now allways drag
    int		ximgdrag = 0;
    int		yimgdrag = 0;
    
    int		imgw = -1;
    int		imgh = -1;
    //int		xoff = 0;
    //int		yoff = 0;
    double	scale = 1.0;  // will be changed in init
    double      LineData[];   // will be filled during "plot"
    double      AxisData[];   // will be filled during "plot"
    String      XAxisTitle="X";
    String      YAxisTitle="Y";
    // boolean     AspectLocked=false; // will prevent some scaling operations
    boolean AspectFromView=false;  // if true the aspect ratio of this view is fixed to the first (local x display direction) axis of the data and the scale is defined by the data scaling information.
    CheckboxMenuItem  AspectLocked;
    boolean	focus = false;
    boolean     DispPlot = false;
    // Image	origimage;
    Image	curimage;
    Container	applet;
    ImgPanel    myPanel; // just for the case, that this (histogram) window was generated by another owner
    ImageCanvas   otherCanvas1;  // other dimension object (x dimension in this canvas)
    ImageCanvas   otherCanvas2;  // other dimension object (y dimension in this canvas)
    My3DData    my3ddata;
    Vector<Integer> PlanesXs, PlanesYs, PlanesXe, PlanesYe;  // this is a duplicate used for displaying the lines

    boolean hastoinit = true;
    int     DimNr=0;
    String  mytitle = "A Slice";
    PositionLabel label;
    PopupMenu MyPopupMenu;

public double PositionValue=1.0;   // value of dimension, that is controlled by this canvas
public double DataOffset=0.0;   // this is used for display
private int  MaxPos=1; 

   public ImageCanvas(Container app, ImgPanel mp, My3DData data3d, int mydimnr, String myt) {

        PlanesXs= new Vector<Integer>();PlanesYs= new Vector<Integer>();
    	PlanesXe= new Vector<Integer>();PlanesYe= new Vector<Integer>();
    	MyPopupMenu =new PopupMenu(myt);  // tear off menu
    	add(MyPopupMenu);
        MenuItem tmp;
        Menu SubMenu = new Menu("Navigation",false);  // can eventually be dragged to the side
        MyPopupMenu.add(SubMenu);
	tmp = new MenuItem("Next slice [page up, ) ]");
	tmp.addActionListener(new MyMenuProcessor(this,')')); SubMenu.add(tmp);
	tmp = new MenuItem("Previous slice [page down, ( ]");
	tmp.addActionListener(new MyMenuProcessor(this,'(')); SubMenu.add(tmp);
	tmp = new MenuItem("Next element (color) [e]");
	tmp.addActionListener(new MyMenuProcessor(this,'e')); SubMenu.add(tmp);
	tmp = new MenuItem("Previous element (color) [E]");
	tmp.addActionListener(new MyMenuProcessor(this,'E')); SubMenu.add(tmp);
	tmp = new MenuItem("Next time [shift-down, ',']");
	tmp.addActionListener(new MyMenuProcessor(this,',')); SubMenu.add(tmp);
	tmp = new MenuItem("Previous time [shift-up, '.']");
	tmp.addActionListener(new MyMenuProcessor(this,'.')); SubMenu.add(tmp);

        SubMenu = new Menu("Display",false);  // can eventually be dragged to the side
        MyPopupMenu.add(SubMenu);
        tmp = new MenuItem("Initialize [i]");
	tmp.addActionListener(new MyMenuProcessor(this,'i')); SubMenu.add(tmp);
        tmp = new MenuItem("Initi Global Threshold [I]");
	tmp.addActionListener(new MyMenuProcessor(this,'I')); SubMenu.add(tmp);
        tmp = new MenuItem("Toggle Plot Display [q]");
	tmp.addActionListener(new MyMenuProcessor(this,'q')); SubMenu.add(tmp);
        tmp = new MenuItem("Zoom into square ROI [Z]");
	tmp.addActionListener(new MyMenuProcessor(this,'Z')); SubMenu.add(tmp);
        
        AspectLocked = new CheckboxMenuItem("Aspect Locked [@]"); //  , false
        SubMenu.add(AspectLocked);  // also responds to short cuts
        AspectLocked.addActionListener(new MyMenuProcessor(this,'@')); 
        
        tmp = new MenuItem("Zoom in [A]");
	tmp.addActionListener(new MyMenuProcessor(this,'A')); SubMenu.add(tmp);
        tmp = new MenuItem("Zoom out [a]");
	tmp.addActionListener(new MyMenuProcessor(this,'a')); SubMenu.add(tmp);
        tmp = new MenuItem("Zoom in perpend. [>]");
	tmp.addActionListener(new MyMenuProcessor(this,'>')); SubMenu.add(tmp);
        tmp = new MenuItem("Zoom in perpend. [<]");
	tmp.addActionListener(new MyMenuProcessor(this,'<')); SubMenu.add(tmp);
    	
        SubMenu = new Menu("Projections",false);  // can eventually be dragged to the side
        MyPopupMenu.add(SubMenu);
        tmp = new MenuItem("Toggle max intensity projection [p]");
	tmp.addActionListener(new MyMenuProcessor(this,'p')); SubMenu.add(tmp);
        tmp = new MenuItem("Toggle sum projection [P]");
	tmp.addActionListener(new MyMenuProcessor(this,'P')); SubMenu.add(tmp);
	applet = app;
        myPanel = mp;
        my3ddata=data3d;
        DimNr=mydimnr;
	mytitle=myt;
        MaxPos = data3d.sizes[mydimnr];
	PositionValue= MaxPos/2;  // init to middle
        ROIs=0; ROIe=MaxPos-1;
	
	// origimage = my3ddata.GiveSection(DimNr,(int) (PositionValue));
	// pickImage();
	setBounds(0, 0, 100, 100);
	addMouseListener(this); // register this class for handling the events in it
	addKeyListener(this); // register this class for handling the events in it
	addMouseMotionListener(this); // register this class for handling the events in it
	addFocusListener(this); // register this class for handling the events in it
        }

   public int getMaxPos() {
	   return MaxPos;
   }

    public void TakeOtherCanvas1(ImageCanvas thecan) {
      otherCanvas1=thecan;
    }

    public void TakeOtherCanvas2(ImageCanvas thecan) {
      otherCanvas2=thecan;
    }


  public void ConnectLabel(PositionLabel alabel) {
      label=alabel;
  }

  public boolean LimitPosition(int space) {  // limits the image positions to within the canvas (if not zoomed)
      if (space > scale*MaxPos)  // More space available than image
      {
	if (dadd < 0)
        {dadd = 0;return false;}
        else
            if (space - dadd - scale*MaxPos < 0) // distance of image to the right border is smaller than zero
            { dadd = space - ((int) (scale*MaxPos));return false;}
      }
      else  // Image is bigger than space
          if (dadd > 0)
          {dadd = 0; return false;}
          else
            if (space - dadd - scale*MaxPos > 0) // distance of image to the right border is smaller than zero
            { dadd = space - ((int) (scale*MaxPos));return false;}
        return true;
  }

  public void InitScaling() {
	Rectangle r = getBounds();
            
        double myaspect = my3ddata.GetScale(0,otherCanvas1.DimNr) / my3ddata.GetScale(0,otherCanvas2.DimNr);
        double myZaspect = my3ddata.GetScale(0,otherCanvas1.DimNr) / my3ddata.GetScale(0,DimNr);
    	double scalex=r.width/((double) otherCanvas1.MaxPos);
        double scaley=r.height/((double) otherCanvas2.MaxPos);
	// if ((scale1 > otherCanvas1.scale) ||
          //   (otherCanvas1.scale == 0.0))    
        // if ((scale1 > otherCanvas2.scale) ||
        //     (otherCanvas2.scale == 0.0)) 
        //System.out.println("My Aspect are " + myaspect +", "+myZaspect+"\n");
        
        if (AspectLocked.getState() || AspectFromView)
        {
            if (scalex > scaley * myaspect)   // fit it into the bigger dimension
                scalex = scaley * myaspect;
            else
                scaley = scalex / myaspect;
           //scalex = scalex * myZaspect;
           scaley = scalex /myaspect;
           otherCanvas1.scale = scalex;   // beeing locked forces to overwrite
           otherCanvas1.dadd = 0;
           otherCanvas2.scale = scaley;
           otherCanvas2.dadd = 0;
           if (otherCanvas1.AspectLocked.getState() || otherCanvas1.AspectFromView ||
        		   otherCanvas2.AspectLocked.getState() || otherCanvas2.AspectFromView)
           {
        	   scale=scalex/myZaspect;
           }
        }        
        	
        if (! otherCanvas2.AspectLocked.getState())
        {
            otherCanvas1.scale = scalex;
            otherCanvas1.dadd = 0;
        }
        if (! otherCanvas1.AspectLocked.getState())
        {
            otherCanvas2.scale = scaley;
            otherCanvas2.dadd = 0;
        }
        DispPlot = false;
        if (DimNr == 0)
            if (my3ddata.GetSize(2) <= 1)
                DispPlot = true;
        if (DimNr == 1)
            if (my3ddata.GetSize(2) <= 1)
                DispPlot = true;
        if (DimNr == 2)
            if (my3ddata.GetSize(0) <= 1)
                DispPlot = true;    
  }

  Color GetMarkerColor(int e) {
      return my3ddata.GetMarkerColor(e);
   }   
   
   public void plot(Graphics g) {  // Plots 1D-data
    Rectangle r = getBounds();
    // Color bg = getBackground();
    g.setColor(Color.black);
    g.fillRect(0,0,r.width-1,r.height-1);
    g.setColor(Color.white);
    
    int px,py,pz;
    int Size;
    int ActPos=0;
    int XAxisDim=0;
    double xDOff = my3ddata.ElementAt(my3ddata.GetActiveElement()).DisplayOffset[otherCanvas1.DimNr];
    double yDOff = my3ddata.ElementAt(my3ddata.GetActiveElement()).DisplayOffset[otherCanvas2.DimNr];
    double Off = my3ddata.ElementAt(my3ddata.GetActiveElement()).DisplayOffset[DimNr];
    if (DimNr==0) { // Plot along Y, but directed along X
        Size = my3ddata.SizeY;
        px = (int) (PositionValue);
        py = (int) (otherCanvas2.PositionValue);
        pz = (int) (otherCanvas1.PositionValue);
        g.drawLine(r.width-10,10,r.width-10,r.height-10);
        // g.drawLine(10,r.height-10,r.width-10,r.height-10);
        g.setColor(Color.green);
        ActPos = (int) otherCanvas2.PositionValue;
        int pos = MouseFromY(ActPos+(int) yDOff) +(int)(0.5*otherCanvas2.scale);
        // MouseFromY(otherCanvas2.PositionValue+yDOff)+(int)(0.5*otherCanvas2.scale);
        g.drawLine(0,pos,r.width-1,pos);        
        XAxisDim=1;
        }
    else if (DimNr==1) {  // Plot along X
        Size = my3ddata.SizeX;
        px = (int) (otherCanvas1.PositionValue);
        py = (int) (PositionValue);
        pz = (int) (otherCanvas2.PositionValue);
        // g.drawLine(10,10,10,r.height-10);
        g.drawLine(10,r.height-10,r.width-10,r.height-10);
        g.setColor(Color.green);
        ActPos = (int) otherCanvas1.PositionValue;
        int pos = MouseFromX(ActPos+(int) xDOff)+(int)(0.5*otherCanvas1.scale);
        g.drawLine(pos,0,pos,r.height-1);
        XAxisDim=0;
        }
   else {   // plot along Z, but directed along X
        Size = my3ddata.SizeZ;
        px = (int) (otherCanvas1.PositionValue);
        py = (int) (otherCanvas2.PositionValue);
        pz = (int) (PositionValue);
        // g.drawLine(10,10,10,r.height-10);
        g.drawLine(10,r.height-10,r.width-10,r.height-10);
        g.setColor(Color.green);
        ActPos = (int) PositionValue;
        int pos =(int)((ActPos+ (int) Off)*r.width/MaxPos) +(int)(0.5*scale);
        g.drawLine(pos ,0,pos,r.height-1);
        XAxisDim=2;
        }

    String XAxisName = my3ddata.GetAxisNames()[XAxisDim];
    String XAxisUnit = my3ddata.GetAxisUnits()[XAxisDim];
    XAxisTitle= XAxisName+" ["+XAxisUnit+"]";

    String YAxisName = my3ddata.GetValueName(my3ddata.GetActiveElement());
    String YAxisUnit = my3ddata.GetValueUnit(my3ddata.GetActiveElement());

    if (my3ddata.GetProjectionMode(DimNr))
    {
        String test;
        if (! my3ddata.GetMIPMode(DimNr))
            test=", Avg. Proj.";
        else
            test=", Max. Proj.";
        g.drawString(test, r.width - test.length() * 9 , 12); // my3ddata.GetUnitsX(-1));       
        YAxisTitle=YAxisName+" ["+YAxisUnit+"]"+test;
    }
    else
        YAxisTitle=YAxisName+" ["+YAxisUnit+"]";
        
    int lxnew=0, lxold=0,lynew=0, lyold=0;
    for (int e=0;e<my3ddata.Elements;e++)
    {
    xDOff = my3ddata.ElementAt(my3ddata.GetActiveElement()).DisplayOffset[otherCanvas1.DimNr];
    yDOff = my3ddata.ElementAt(my3ddata.GetActiveElement()).DisplayOffset[otherCanvas2.DimNr];
    Off = my3ddata.ElementAt(my3ddata.GetActiveElement()).DisplayOffset[DimNr];
    if (my3ddata.InOverlayDispl(e) || (my3ddata.ActiveElement == e))
    {
        g.setColor(GetMarkerColor(e));
                
        for (int pos=0;pos < Size;pos++)   // the loop iterating over the x-plot-axis
            {
                double val=0,valtrue=0;
                if (! my3ddata.ProjMode[DimNr])  // this is not a projection
                {
                if (DimNr==0)
                    {val = my3ddata.NormedValueAt(px,pos,pz,e);
                     valtrue = my3ddata.ValueAt(px,pos,pz,e);
                     lynew = MouseFromY(pos + (int) yDOff)+(int)(0.5*otherCanvas2.scale);
                     lxnew = r.width-10 - (int) ((r.width - 20)*(val));
                    }
                else if (DimNr==1)
                    {val = my3ddata.NormedValueAt(pos,py,pz,e);
                     valtrue = my3ddata.ValueAt(pos,py,pz,e);
                     lxnew = MouseFromX(pos+ (int) xDOff) +(int)(0.5*otherCanvas1.scale);
                     lynew = r.height - 10 - (int) ((r.height - 20 )*(val));
                    }
                else if (DimNr==2)
                    {val = my3ddata.NormedValueAt(px,py,pos,e);
                     valtrue = my3ddata.ValueAt(px,py,pos,e);
                     lxnew = (pos  + (int) Off) * r.width / Size + (int)(0.5*scale);
                     lynew = r.height - 10 - (int) ((r.height - 20)*(val));
                    }
                }
                else  // this is a projection
                {
                val = my3ddata.NormedProjValueAt(DimNr,pos,e);
                valtrue = my3ddata.ProjValueAt(DimNr,pos,e);
                if (DimNr==0)
                    {
                     lynew = MouseFromY(pos+ (int) yDOff)+(int)(0.5*otherCanvas2.scale);
                     lxnew = r.width-10 - (int) ((r.width - 20)*(val));
                    }
                else if (DimNr==1)
                    {
                     lxnew = MouseFromX(pos +  (int) xDOff) +(int)(0.5*otherCanvas1.scale);
                     lynew = r.height - 10 - (int) ((r.height - 20 )*(val));
                    }
                else if (DimNr==2)
                    {
                     lxnew = (pos  + (int) Off) * r.width / Size + (int)(0.5*scale);
                     lynew = r.height - 10 - (int) ((r.height - 20)*(val));
                    }
                }
                
                if (pos != 0)
                    g.drawLine(lxold,lyold,lxnew,lynew);
                if (e == my3ddata.GetActiveElement())
                {
                    if (LineData == null)
                        LineData = new double[Size];
                    LineData[pos] = valtrue;

                    if (AxisData == null)
                        AxisData = new double[Size];
                    AxisData[pos] = pos*my3ddata.GetScale(0,XAxisDim)+my3ddata.GetOffset(0,XAxisDim); 
                    
                    if (pos == ActPos)
                    {
                        g.fillOval(lxnew-5,lynew-5,10,10);
                        if (my3ddata.ProjMode[DimNr])  // this is not a projection
                        {
                            double ProjVal = my3ddata.ProjValueAt(DimNr,pos,e);
                            g.drawString(label.CreateValueString(ProjVal), 5 , 12); 
                        }
                        else
                        {
                            g.drawString(label.GetValueString(), 5 , 12); 
                            g.drawString(label.GetPositionString(), 5 , 24); 
                        }
                        if (my3ddata.GetLogMode())
                        {
                        String test="Log. Mode";
                        g.drawString(test, r.width - test.length() * 9 , 24); // my3ddata.GetUnitsX(-1));
                        }
                    }
                }
                
                lxold=lxnew;lyold=lynew;
            }
    }
    } // end of element loop
    
    g.setColor(Color.white);
    if (my3ddata.SquareROIs())
      {
      if (otherCanvas1.ROIs >= 0 || otherCanvas2.ROIs >= 0)
      if (DimNr ==1)
        {
        int xrs = MouseFromX(otherCanvas1.ROIs);
        int xre = MouseFromX(otherCanvas1.ROIe);
        int tmp;
        if (xrs > xre) {tmp=xrs;xrs=xre;xre=tmp;}
        g.drawRect(xrs, 0, xre-xrs, r.height-9);
        }
       else if (DimNr == 0)
         {
         int yrs = MouseFromY(otherCanvas2.ROIs);
         int yre = MouseFromY(otherCanvas2.ROIe);
         int tmp;
         if (yrs > yre) {tmp=yrs;yrs=yre;yre=tmp;}
         g.drawRect(0, yrs, r.width-9, yre-yrs);
         }
       else 
         {
         g.drawRect(ROIs*r.width/MaxPos, 0, (ROIe-ROIs)*r.width/MaxPos, r.height-9);
         }
    }            
}
 
public void paint(Graphics g) {
	Rectangle r = getBounds();

  	if (hastoinit)
	  {
	    hastoinit = false;
	        InitScaling();
	        CalcPrev();
	        otherCanvas1.repaint();
	        otherCanvas2.repaint();
	  }

        if (DispPlot)
            {
                plot(g);
                return;
            }
        
	int xm = (int) (otherCanvas1.MaxPos*otherCanvas1.scale);
	int ym = (int) (otherCanvas2.MaxPos*otherCanvas2.scale);

	int xOff = otherCanvas1.PixelFromDataPos(my3ddata.ElementAt(my3ddata.GetActiveElement()).DisplayOffset[otherCanvas1.DimNr]);
	int yOff = otherCanvas2.PixelFromDataPos(my3ddata.ElementAt(my3ddata.GetActiveElement()).DisplayOffset[otherCanvas2.DimNr]);
	//int xOff = otherCanvas1.dadd+xDOff;
	//int yOff = otherCanvas2.dadd+yDOff;
	// System.out.println("paint xyOff"+xOff+", "+yOff+"\n");
	
	g.drawImage(curimage, xOff, yOff , xm, ym, this);

	// Color bg = getBackground();
	//g.setColor(bg);
	g.setColor(Color.black);
	g.fillRect(0,0,r.width-1,yOff);
	g.fillRect(0,0,xOff,r.height-1);

	g.fillRect(xm+1+xOff,0,r.width-1,r.height-1);
	g.fillRect(0,ym+1+yOff,r.width-1,r.height-1);

	if (focus) {
	    g.setColor(Color.red);
	} else {
	    g.setColor(Color.darkGray);
	}
	g.drawRect(0, 0, r.width-1, r.height-1);   // draw the frame

        g.setColor(Color.white);
        if (ROIMoveStarted)
           g.setColor(Color.gray);
        
        if (my3ddata.SquareROIs()) // ROIs should not incorporate the data offset
        {
            // if (otherCanvas1.ROIs >= 0 && otherCanvas2.ROIs >= 0)
            if   (true) //! my3ddata.GetProjectionMode(DimNr) || myPanel.ROIstarted)
                {
                    int xrs,yrs,xre,yre;
                    if (myPanel.ROIstarted)  // ROI is not finished but started
                    {
                    xrs = DMouseFromX(otherCanvas1.ROIs);
                    yrs = DMouseFromY(otherCanvas2.ROIs);
                    xre = DMouseFromX(otherCanvas1.ROIe);
                    yre = DMouseFromY(otherCanvas2.ROIe);
                    }
                    else
                    {
                    Rectangle r2 = my3ddata.GetSqrROI(DimNr);
                    xrs = DMouseFromX(r2.x + ROIMoveDX);
                    yrs = DMouseFromY(r2.y + ROIMoveDY);
                    xre = DMouseFromX(r2.x+r2.width + ROIMoveDX);
                    yre = DMouseFromY(r2.y+r2.height + ROIMoveDY);
                    }
                int tmp;
                if (xrs > xre) {tmp=xrs;xrs=xre;xre=tmp;}
                if (yrs > yre) {tmp=yrs;yrs=yre;yre=tmp;}
                g.drawRect(xrs, yrs, xre-xrs, yre-yrs);
                }
        }
        else if   (true) // ! my3ddata.GetProjectionMode(DimNr) || LineROIStarted)
            {
                if (LineROIStarted && tmpROIPolygons != null)
                {
                    	int xold=0,yold=0,xnew=0,ynew=0;
                    	for (int s=0;s<tmpROIPolygons.npoints;s++)
                    	{
                    		xnew = tmpROIPolygons.xpoints[s];
                    		ynew = tmpROIPolygons.ypoints[s];

                    		xnew = DMouseFromX(xnew+ ROIMoveDX);
                    		ynew = DMouseFromY(ynew+ ROIMoveDY);
                    		if (s>0)
                    			g.drawLine(xold, yold, xnew, ynew);
                    		xold = xnew; yold = ynew;
                    	}
                	
                    int xrs = DMouseFromX(otherCanvas1.LROIs);
                    int yrs = DMouseFromY(otherCanvas2.LROIs);
                    int xre = DMouseFromX(otherCanvas1.LROIe);
                    int yre = DMouseFromY(otherCanvas2.LROIe);
                    g.drawLine(xrs, yrs, xre, yre);             // line in progress
                }
                float coords[] = new float[2];
                
                int Rsize = my3ddata.GetPolyROISize(DimNr);
                if (Rsize>0)
                {
                    my3ddata.GetPolyROICoords(DimNr,0,coords);
                    int xold = DMouseFromX(coords[0] + ROIMoveDX); 
                    int yold = DMouseFromY(coords[1] + ROIMoveDY);
                    int xnew,ynew;
                    for (int s=1;s<Rsize;s++)
                    	{
                        my3ddata.GetPolyROICoords(DimNr,s,coords);
                        xnew = DMouseFromX(coords[0]+ ROIMoveDX);
                        ynew = DMouseFromY(coords[1]+ ROIMoveDY);
                        g.drawLine(xold, yold, xnew, ynew);
                        xold = xnew; yold = ynew;
                    	}
                    my3ddata.GetPolyROICoords(DimNr,0,coords);
                    xnew = DMouseFromX(coords[0]+ ROIMoveDX);
                    ynew = DMouseFromY(coords[1]+ ROIMoveDY);
                    g.drawLine(xold, yold, xnew, ynew); // to close the ROI
                }
            }
        
        // Below the markers are drawn into the image 
        
        int xp,yp,xprev=0,yprev=0;
        int px = (int) (myPanel.c2.PositionValue); // Get the absolute x-position of the cursor
        int py = (int) (myPanel.c3.PositionValue); // Get the absolute y-position
        int pz = (int) (myPanel.c1.PositionValue); // Get the absolute z-position
        int element = (int) my3ddata.ActiveElement; // Get the active time
        int time = (int) my3ddata.ActiveTime; // Get the active time
        int ActPosition[] = {px,py,pz,element,time};
        NumberFormat nf2 = java.text.NumberFormat.getNumberInstance(Locale.US);
    	nf2.setMaximumFractionDigits(4);
    	nf2.setGroupingUsed(false);

    	boolean foundactive=false;

        // ColorSpace myHLS= new ICC_ColorSpace(ICC_Profile.getInstance(ColorSpace.TYPE_HLS));
        for (int l=0;l<my3ddata.NumMarkerLists();l++) // draw markers for marked points
        {
            int actlistpos= my3ddata.ActiveMarkerListPos();
        	boolean didannotate=false;
            if (my3ddata.ShowAllLists || l == actlistpos)
            for (int p=0;p<my3ddata.NumMarkers(l);p++) // draw markers for marked points
	    {
                APoint Pt=my3ddata.GetPoint(p,l);
                if (my3ddata.ShowSpectralTrack)
                {
                    // float cols[]={((float)Pt.coord[my3ddata.TrackDirection])/((float) my3ddata.sizes[my3ddata.TrackDirection]),0.9f,0.9f};
                    g.setColor(Bundle.ColFromHue(((float)Pt.coord[my3ddata.TrackDirection])/((float) my3ddata.sizes[my3ddata.TrackDirection])));
                }
                else
                    g.setColor(new Color(Pt.mycolor));
                double coords[] =Pt.coord;
		if (DimNr == 0)
		    {
			xp = DMouseFromX(coords[2]);
			yp = DMouseFromY(coords[1]);
		    }
		else if (DimNr == 1)
		    {
			xp = DMouseFromX(coords[0]);
			yp = DMouseFromY(coords[2]);
		    }
		else 
		    {
			xp = DMouseFromX(coords[0]);
			yp = DMouseFromY(coords[1]);
		    }
                 // System.out.println("Draw Rect nr "+l+", "+p+" xy : "+xp+" "+yp);
        	if (my3ddata.MarkerDisplayed(Pt,ActPosition))
        		Pt.isDisplayed = true;
        	else
        		Pt.isDisplayed = false;

        	int xDOff = otherCanvas1.PixelFromDataPos(my3ddata.ElementAt((int) (Pt.coord[3]+0.5),(int) (Pt.coord[4]+0.5)).DisplayOffset[otherCanvas1.DimNr]) - otherCanvas1.dadd;
        	int yDOff = otherCanvas2.PixelFromDataPos(my3ddata.ElementAt((int) (Pt.coord[3]+0.5),(int) (Pt.coord[4]+0.5)).DisplayOffset[otherCanvas2.DimNr]) - otherCanvas2.dadd;

                 if (Pt.isDisplayed)
                 {
                	 if (Pt.tagged)
                        g.fillOval(xp-MarkerLists.dx + xDOff,yp-MarkerLists.dy + yDOff,MarkerLists.dx*2+1,MarkerLists.dx*2+1);
                	 else
                    	g.drawRect(xp-MarkerLists.dx + xDOff,yp-MarkerLists.dy + yDOff,MarkerLists.dx*2+1,MarkerLists.dx*2+1);
                    if (myPanel.DraggedMarker == Pt)  // If currectly being dragged, fill it
                    {
                    	if (Pt.tagged)
                        	g.drawOval(xp-MarkerLists.dx-1 + xDOff,yp-MarkerLists.dy-1 + yDOff,MarkerLists.dx*2+3,MarkerLists.dx*2+3);
                    	else
                        	g.fillRect(xp-MarkerLists.dx + xDOff,yp-MarkerLists.dy + yDOff,MarkerLists.dx*2+1,MarkerLists.dx*2+1);
                    }

                    if (! foundactive && my3ddata.CheckActiveMarker(l,p,px,py,pz,element,time)) // coordinates of display,   p : Numer of marker
                    //if (my3ddata.ActiveMarkerPos() == p && (l == actlistpos))
                    {
                    	g.setColor(Color.white);
                    	if (Pt.tagged)
                        	g.fillOval(xp-MarkerLists.dx-1 + xDOff,yp-MarkerLists.dy-1 + yDOff,MarkerLists.dx*2+3,MarkerLists.dx*2+3);
                    	else
                        	g.drawRect(xp-MarkerLists.dx-1 + xDOff,yp-MarkerLists.dy-1 + yDOff,MarkerLists.dx*2+3,MarkerLists.dx*2+3);
                    	foundactive=true;
                    }

                    if (! didannotate && my3ddata.Annotate)  // show number for first track in list only
                    {
                    	didannotate=true;
                   	 	String ListName=my3ddata.GetMarkerListName(l);
                   	 	if (ListName != null && ! ListName.equals(""))
                   	 		g.drawString(ListName,xp+10 + xDOff,yp+10 + yDOff); 
                   	 // g.drawString(nf2.format(l+1),xp+10,yp+10); 
                    }
                 }
                 //if (my3ddata.ActiveMarkerPos() == p && (l == actlistpos))
                 //	 g.setColor(Color.white);
              
          		boolean shouldDraw=true;

          		if (p == 0)
          		{
          			if (my3ddata.HasParent1(l))
          			{
          				APoint oPt=my3ddata.GetParent1EndOfTrack(l);
          				int xpOff = otherCanvas1.PixelFromDataPos(my3ddata.ElementAt((int) (oPt.coord[3]+0.5),(int) (oPt.coord[4]+0.5)).DisplayOffset[otherCanvas1.DimNr]) - otherCanvas1.dadd;
          				int ypOff = otherCanvas2.PixelFromDataPos(my3ddata.ElementAt((int) (oPt.coord[3]+0.5),(int) (oPt.coord[4]+0.5)).DisplayOffset[otherCanvas2.DimNr]) - otherCanvas2.dadd;
          				coords = oPt.coord;
          				if (DimNr == 0)
          				{xprev = DMouseFromX(coords[2]) +xpOff;yprev = DMouseFromY(coords[1])+ypOff;}
          				else if (DimNr == 1)
          				{xprev = DMouseFromX(coords[0]) +xpOff;yprev = DMouseFromY(coords[2])+ypOff;}
          				else 
          				{xprev = DMouseFromX(coords[0]) +xpOff;yprev = DMouseFromY(coords[1])+ypOff;}
          				g.setColor(Color.gray);
          			}
                	 else shouldDraw=false;

          			if (shouldDraw && my3ddata.ConnectionShown)
          			{
          				if ((my3ddata.ActiveMarkerPos() == p && (l == actlistpos)) || (my3ddata.ShowFullTrace && (my3ddata.ShowAllTrees || my3ddata.CommonRoot(l,actlistpos)))) 
          				{
          					g.drawLine(xprev,yprev,xp + xDOff,yp + yDOff);
          				}
          			}
          			shouldDraw=true;
          			if (my3ddata.HasParent2(l))
          			{
          				APoint oPt=my3ddata.GetParent2EndOfTrack(l);
          				int xpOff = otherCanvas1.PixelFromDataPos(my3ddata.ElementAt((int) (oPt.coord[3]+0.5),(int) (oPt.coord[4]+0.5)).DisplayOffset[otherCanvas1.DimNr]) - otherCanvas1.dadd;
          				int ypOff = otherCanvas2.PixelFromDataPos(my3ddata.ElementAt((int) (oPt.coord[3]+0.5),(int) (oPt.coord[4]+0.5)).DisplayOffset[otherCanvas2.DimNr]) - otherCanvas2.dadd;
          				coords = oPt.coord;
          				if (DimNr == 0)
          				{xprev = DMouseFromX(coords[2]) +xpOff;yprev = DMouseFromY(coords[1])+ypOff;}
          				else if (DimNr == 1)
          				{xprev = DMouseFromX(coords[0]) +xpOff;yprev = DMouseFromY(coords[2])+ypOff;}
          				else 
          				{xprev = DMouseFromX(coords[0]) +xpOff;yprev = DMouseFromY(coords[1])+ypOff;}
          				g.setColor(Color.gray);
          			}
                	 else shouldDraw=false;
          		}

          		if (shouldDraw && my3ddata.ConnectionShown)
      			{
      				if ((my3ddata.ActiveMarkerPos() == p && (l == actlistpos)) || (my3ddata.ShowFullTrace && (my3ddata.ShowAllTrees || my3ddata.CommonRoot(l,actlistpos)))) 
      				{
      					g.drawLine(xprev,yprev,xp + xDOff,yp + yDOff);
      				}
      			}
                 
                xprev=xp + xDOff;yprev=yp + yDOff;
	    }
        }
        

    xp = getCrossHairX();
    yp = getCrossHairY();
    g.setColor(Color.green);
        
	if (otherCanvas1 != null)   // draw coordinate lines
	 {
	   g.drawLine(xp,0,xp,yp-10);
	   g.drawLine(xp,yp+10,xp,r.height-1);
	 }
	if (otherCanvas2 != null)
	 {
	   g.drawLine(0,yp,xp-10,yp);
	   g.drawLine(xp+10,yp,r.width-1,yp);
	 }
	g.setColor(Color.white);
        
        if (my3ddata.GetProjectionMode(DimNr))
        {
            String test;
            if (! my3ddata.GetMIPMode(DimNr))
                test="Avg. Proj.";
            else
                test="Max. Proj.";
            g.drawString(test, r.width - test.length() * 9 , 12); // my3ddata.GetUnitsX(-1));
        }

        g.drawString(mytitle,10,15);
    }

  public int getCrossHairX() {
	    double xDOff = my3ddata.ElementAt(my3ddata.GetActiveElement()).DisplayOffset[otherCanvas1.DimNr];
	    return MouseFromX(otherCanvas1.PositionValue+xDOff)+(int)(0.5*otherCanvas1.scale);
  }
  
  public int getCrossHairY() {
	    double yDOff = my3ddata.ElementAt(my3ddata.GetActiveElement()).DisplayOffset[otherCanvas2.DimNr];
	    return MouseFromY(otherCanvas2.PositionValue+yDOff)+(int)(0.5*otherCanvas2.scale);	  	  
  }

  public int getCrossHairZ() {
	    double zDOff = my3ddata.ElementAt(my3ddata.GetActiveElement()).DisplayOffset[DimNr];
	    return PixelFromDataPos(PositionValue+zDOff)+(int)(0.5*scale);	  	  
  }


  public void update(Graphics g) { // eliminate flickering
      paint(g);
      // label.CoordsChanged();  // due to roundoff errors?  Why is this necessary to display the elements?
  }

    static final long updateRate = 100;
    public synchronized boolean imageUpdate(Image img, int infoflags,
					    int x, int y, int w, int h) {
	if (img != curimage) {
	    return false;
	}
	boolean ret = true;
	boolean dopaint = false;
	long updatetime = 0;
	if ((infoflags & WIDTH) != 0) {
	    imgw = w;
	    dopaint = true;
	}
	if ((infoflags & HEIGHT) != 0) {
	    imgh = h;
	    dopaint = true;
	}
	if ((infoflags & (FRAMEBITS | ALLBITS)) != 0) {
	    dopaint = true;
	    ret = false;
	} else if ((infoflags & SOMEBITS) != 0) {
	    dopaint = true;
	    updatetime = updateRate;
	}
	if ((infoflags & ERROR) != 0) {
	    ret = false;
	}
	if (dopaint) {
	    repaint(updatetime);
	}
	return ret;
    } 
    
    public synchronized Image pickImage() {  // selects the image
        if (! DispPlot)  // otherwise no new image is needed for this pane
            curimage = my3ddata.GiveSection(DimNr,(int) (PositionValue));
	return curimage;
    }

    public int PixelFromDataPos(double pos) { // rounds at Data level
	// return dadd+(int) ((((int) pos)+0.5)*scale+0.5);
	return dadd+(int) (((int) pos)*scale+0.5);
    }
    
    public int MouseFromX(double pos) {  // converts Data voxel coordinates into display coordinates
    	return otherCanvas1.PixelFromDataPos(pos);
    }
    
    public int MouseFromY(double pos) {
    	return otherCanvas2.PixelFromDataPos(pos);
    }

    public int DPixelFromDataPos(double pos) { // rounds at Data level
    	return dadd+(int) ((pos+0.5)*scale);
        }

    public int DMouseFromX(double pos) {  // rounds at pixel level
    	return otherCanvas1.DPixelFromDataPos(pos);
    }
    
    public int DMouseFromY(double pos) {
    	return otherCanvas2.DPixelFromDataPos(pos);
    }

    public double DataPosFromPixel(int pixelpos) {
    	double result= ((pixelpos-dadd)/scale );
    	if (result < 0) result=0;
    	if (result > MaxPos-1) result=MaxPos-1;
    	return result;    	
    }

    public double DataPosFromPixelNoLimit(int pixelpos) {
    	return ((pixelpos-dadd)/scale );
    }
    
    public double XFromMouse(int xnew) { // converts display pixel coordinates into Data voxel coordinates
	return otherCanvas1.DataPosFromPixel(xnew);
    }

    public double YFromMouse(int ynew) { // converts display pixel coordinates into Data voxel coordinates
    	return otherCanvas2.DataPosFromPixel(ynew);
    }

    public double XFromMouseNoLimit(int xnew) { // converts display pixel coordinates into Data voxel coordinates
    	return otherCanvas1.DataPosFromPixelNoLimit(xnew);
        }

    public double YFromMouseNoLimit(int ynew) { // converts display pixel coordinates into Data voxel coordinates
        	return otherCanvas2.DataPosFromPixelNoLimit(ynew);
        }

  void updateothers(int xnew, int ynew) {  // important, when a position has changed
	  double xOff = my3ddata.ElementAt(my3ddata.ActiveElement).DisplayOffset[otherCanvas1.DimNr];
      double yOff = my3ddata.ElementAt(my3ddata.ActiveElement).DisplayOffset[otherCanvas2.DimNr];

      // Rectangle r = getBounds();
	    double newPos1 = XFromMouse((int)(xnew-otherCanvas1.scale*xOff));

  	    if (otherCanvas1 != null)
	      {
		if (otherCanvas1.PositionValue != newPos1)
		  {
		    otherCanvas1.PositionValue = newPos1;
		    otherCanvas1.pickImage();
		  }
		 otherCanvas1.repaint();
	      }
	    double newPos2 = YFromMouse((int)(ynew-otherCanvas2.scale*yOff));

	    if (otherCanvas2 != null)
	      {
		if (otherCanvas2.PositionValue != newPos2)
		  {
		    otherCanvas2.PositionValue = newPos2;
		    otherCanvas2.pickImage();
		  }
		 otherCanvas2.repaint();
	      }
        //System.out.println("Pos: " + newPos1 + ", "+ newPos2 +"\n");
	}
 
  public void CalcPrev() {
    xprev = otherCanvas1.DPixelFromDataPos(otherCanvas1.PositionValue);// Position into mouse-coordinates
    yprev = otherCanvas2.DPixelFromDataPos(otherCanvas2.PositionValue);
  }

// Process adjustment events of attached scrollbars
  public void adjustmentValueChanged(AdjustmentEvent e) 
   {
       // if (! e.getValueIsAdjusting())   // The user finished adjusting
       {
           int newtime=e.getValue();
           my3ddata.setTime(newtime);
           UpdateAll();
       }       
   }
  
  
// code for event handling :
// Keybord-Focus events
public void focusGained(FocusEvent e) {
    focus = true;
    repaint();
}

public void focusLost(FocusEvent e) {
    focus = false;
    repaint();
}
// mouse events :
public void mouseEntered(MouseEvent e) {
    CalcPrev();
    requestFocus();
    // pickImage();
}

public void mouseClicked(MouseEvent e) {
	double xOff = my3ddata.ElementAt(my3ddata.ActiveElement).DisplayOffset[otherCanvas1.DimNr];
	double yOff = my3ddata.ElementAt(my3ddata.ActiveElement).DisplayOffset[otherCanvas2.DimNr];
    APoint Pt=my3ddata.MarkerFromPosition(XFromMouseNoLimit(e.getX())-0.5-xOff,YFromMouseNoLimit(e.getY())-0.5-yOff,DimNr,
                                                (2*MarkerLists.dx+1)/otherCanvas1.scale,(2*MarkerLists.dy+1)/otherCanvas2.scale);  // , myPanel.getPositions()
    if (Pt != null)
    {
    	if (Pt == my3ddata.GetActiveMarker())
    	{
    	Pt.Tag(-1);
        repaint();
        updateothers(xprev,yprev);
        label.CoordsChanged();
    	}
    	else
    	{
    		if (my3ddata.FocusDispToMarker)
        	    myPanel.RememberOffset();
    		my3ddata.SetActiveMarker(Pt);
    		if (my3ddata.FocusDispToMarker)
    		{
    			myPanel.setPositions(my3ddata.GetActiveMarker());
    			myPanel.AdjustOffset();
    			CalcPrev();
    			UpdateAll();
    		}
    	}
    }
}

public void mousePressed(MouseEvent e) {
    if (e.isPopupTrigger())
    {
	MyPopupMenu.show(this,e.getX(),e.getY());
        return;
    }

    double xOff = my3ddata.ElementAt(my3ddata.ActiveElement).DisplayOffset[otherCanvas1.DimNr];
	double yOff = my3ddata.ElementAt(my3ddata.ActiveElement).DisplayOffset[otherCanvas2.DimNr];

    if (myPanel.DraggedMarker != null)  // A drag was allready started. The user wants to cancel it.
    {
        myPanel.DraggedMarker.coord[0] = myPanel.SavedMarker.coord[0];
        myPanel.DraggedMarker.coord[1] = myPanel.SavedMarker.coord[1];
        myPanel.DraggedMarker.coord[2] = myPanel.SavedMarker.coord[2];
        myPanel.DraggedMarker = null; // cancell the drag
        repaint();
        updateothers(xprev,yprev);
        label.CoordsChanged();  
        return;
    }

    if (LineROIStarted)
    {
        if (otherCanvas1.LROIs == (int) XFromMouse(e.getX()) && otherCanvas2.LROIs == (int) YFromMouse(e.getY()) && tmpROIPolygons != null)
        {   // User clicked twice :  Finish the ROI
            int Rsize = tmpROIPolygons.npoints;
            if (Rsize <= 2)   // ROI too small -> clear ROI
                my3ddata.ClearPolyROIs(DimNr);
            else
            {
                tmpROIPolygons.addPoint((int) XFromMouse(e.getX()), (int) YFromMouse(e.getY()));
                // float coords[] = new float[2];
                // my3ddata.GetPolyROICoords(DimNr,0,coords);
                my3ddata.TakePolyROI(tmpROIPolygons, DimNr);  // close the ROI and submit
            }
            tmpROIPolygons=null;  // clear all the entries
            LineROIStarted = false;
            // repaint();
            UpdateAll();
            return;
        }
        else    // just add another point to the PolyROI
            {
        	if (tmpROIPolygons != null)
        		tmpROIPolygons.addPoint((int) XFromMouse(e.getX()), (int) YFromMouse(e.getY()));
            // my3ddata.TakePolyROI( (int) XFromMouse(e.getX()), (int) YFromMouse(e.getY()),DimNr);
            }
        otherCanvas1.LROIs = (int) XFromMouse(e.getX());
        otherCanvas2.LROIs = (int) YFromMouse(e.getY());
        return;
     }

    if (e.isControlDown())  // Start a ROI moving event
    {
        ROIMoveStarted=true;
        ROIMoveStartX=(int) (XFromMouse(e.getX())-0.5);
        ROIMoveStartY=(int) (YFromMouse(e.getY())-0.5);
        return;
    }

    if (e.isShiftDown())  // Start a ROI marking event
        if (my3ddata.SquareROIs())
            {
            myPanel.ROIstarted=true;
            otherCanvas1.ROIs = (int) XFromMouse(e.getX());
            otherCanvas2.ROIs = (int) YFromMouse(e.getY());
            return;
            }
        else
            {
            if (! LineROIStarted)  // start a new LineROI
            {
                LineROIStarted=true;
                if (tmpROIPolygons == null)
                	tmpROIPolygons = new Polygon();
                LROIs=-1;
                otherCanvas1.LROIs = (int) XFromMouse(e.getX());
                otherCanvas2.LROIs = (int) YFromMouse(e.getY());
                tmpROIPolygons.addPoint((int) XFromMouse(e.getX()), (int) YFromMouse(e.getY()));
                //my3ddata.ClearPolyROIs(DimNr);
                //my3ddata.TakePolyROI( (int) XFromMouse(e.getX()), (int) YFromMouse(e.getY()),DimNr);
                return;
            }
       }
    else
      {
          
      if (!DispPlot)
        {
          // Check wether a marker was hit
        APoint Pt=my3ddata.MarkerFromPosition(XFromMouseNoLimit(e.getX())-0.5-xOff,YFromMouseNoLimit(e.getY())-0.5-yOff,DimNr,
                                                (2*MarkerLists.dx+1)/otherCanvas1.scale,(2*MarkerLists.dy+1)/otherCanvas2.scale); // , myPanel.getPositions()
          if (Pt != null)
          {
        	  if (Pt != my3ddata.GetActiveMarker()) // (! my3ddata.ShowAllLists) && 
        		  ; // my3ddata.SetActiveMarker(Pt); // will be activated in the release function
        	  else
        	  {
        		  myPanel.DraggedMarker = Pt;
        		  myPanel.SavedMarker = (APoint) Pt.clone();
        	  }
          }
          else  // just a mouse pressed in the empty image area
          {
              // e.isAltGraphDown() ||  // This does not work with matlab
            if ( e.isMetaDown() || e.getClickCount()>1 || (e.getModifiers() & Event.ALT_MASK) != 0)
                ImgDragStarted = true;
            if (ImgDragStarted)  // Only drag the image but do not change coordinates
            {
                ximgdrag = e.getX();
                yimgdrag = e.getY();
                ImgDragStarted=true;
                return;
            }
            else
            {
                xprev = e.getX();   // just saves the pixel coordinate at which the mouse was pressed
                yprev = e.getY();
            }
          }
        }
      else   // This is in plotting mode
        {
        if (DimNr == 0)
            yprev=e.getY();
        else if (DimNr == 1)
            xprev=e.getX();
       else if (DimNr == 2)
            PositionValue =  MaxPos * e.getX() / getBounds().width;
        }
      repaint();
      updateothers(xprev,yprev);
      // updateothers(xprev-MouseFromX(xOff),yprev-MouseFromY(yOff));
      label.CoordsChanged();  
      }  // from else (if shiftdown)
}

public void mouseReleased(MouseEvent e) {
    if (e.isPopupTrigger())
    {
	MyPopupMenu.show(this,e.getX(),e.getY());
        return;
    }
    if (ImgDragStarted)
        ImgDragStarted=false;
    
    if (myPanel.DraggedMarker != null)  // successfully finished dragging
    {
            my3ddata.UpdateMarker(myPanel.DraggedMarker);  // Just in case the COI shall be used
            myPanel.DraggedMarker = null;
            repaint();
            updateothers(xprev,yprev);
            label.CoordsChanged();
            return;
    }

    if (! e.isControlDown())
        { ROIMoveStarted=false;ROIMoveDX=0;ROIMoveDY=0;repaint();}
    
    if (ROIMoveStarted & e.isControlDown())  // finalize
    {
            my3ddata.MoveROI(ROIMoveDX,ROIMoveDY,DimNr);
            ROIMoveStarted=false;
            ROIMoveDX=0;
            ROIMoveDY=0;
            LROIs=-1;
            //repaint();
            UpdateAll();
            return;
    }
    
    int SizeX = otherCanvas1.MaxPos-1;
    int SizeY = otherCanvas2.MaxPos-1;
    if (myPanel.ROIstarted)
    {
        otherCanvas1.ROIe = (int) XFromMouse(e.getX());
        otherCanvas2.ROIe = (int) YFromMouse(e.getY());
        if ((otherCanvas1.ROIe == otherCanvas1.ROIs) && (otherCanvas2.ROIe == otherCanvas2.ROIs))  // delete the ROI
        {
            my3ddata.TakeROI(0,0,SizeX,SizeY,DimNr);
            otherCanvas1.ROIs=0;otherCanvas1.ROIe=otherCanvas1.MaxPos-1;
            otherCanvas2.ROIs=0;otherCanvas2.ROIe=otherCanvas2.MaxPos-1;
            ROIs=0;ROIe=SizeX;
            UpdateAll();
        }
        else if (true) // ((otherCanvas1.ROIe >= otherCanvas1.ROIs) && (otherCanvas2.ROIe >= otherCanvas2.ROIs))
            {
                my3ddata.TakeROI(otherCanvas1.ROIs,otherCanvas2.ROIs,otherCanvas1.ROIe,otherCanvas2.ROIe,DimNr);
                UpdateAll();
            }
    }
    /*if (LineROIStarted)
    {
        otherCanvas1.LROIe = (int) XFromMouse(e.getX());
        otherCanvas2.LROIe = (int) YFromMouse(e.getY());
        if ((otherCanvas1.LROIe == otherCanvas1.LROIs) && (otherCanvas2.LROIe == otherCanvas2.LROIs))  // delete the ROI
        {
            my3ddata.ClearLineROIs();
            PlanesXs.removeAllElements();PlanesYs.removeAllElements();PlanesXe.removeAllElements();PlanesYe.removeAllElements();
            otherCanvas1.PlanesXs.removeAllElements();otherCanvas1.PlanesYs.removeAllElements();otherCanvas1.PlanesXe.removeAllElements();otherCanvas1.PlanesYe.removeAllElements();
            otherCanvas2.PlanesXs.removeAllElements();otherCanvas2.PlanesYs.removeAllElements();otherCanvas2.PlanesXe.removeAllElements();otherCanvas2.PlanesYe.removeAllElements();
        }
        else
        {
            my3ddata.TakeLineROI(otherCanvas1.LROIs,otherCanvas2.LROIs,otherCanvas1.LROIe,otherCanvas2.LROIe,DimNr);
            PlanesXs.addElement(new Integer(otherCanvas1.LROIs));
            PlanesYs.addElement(new Integer(otherCanvas2.LROIs));
            PlanesXe.addElement(new Integer(otherCanvas1.LROIe));
            PlanesYe.addElement(new Integer(otherCanvas2.LROIe));
        }
        LineROIStarted=false;
    }*/
    myPanel.ROIstarted=false;
}

public void mouseExited(MouseEvent e) {
}
// mouse motion events :
public void mouseDragged(MouseEvent e) {
   	double xOff = my3ddata.ElementAt(my3ddata.ActiveElement).DisplayOffset[otherCanvas1.DimNr];
	double yOff = my3ddata.ElementAt(my3ddata.ActiveElement).DisplayOffset[otherCanvas2.DimNr];

    if (ROIMoveStarted)
    {
        if (! e.isControlDown())
            { ROIMoveStarted=false;ROIMoveDX=0;ROIMoveDY=0;repaint();return;}

        ROIMoveDX=(int) (XFromMouse(e.getX())-0.5)-ROIMoveStartX;
        ROIMoveDY=(int) (YFromMouse(e.getY())-0.5)-ROIMoveStartY;
        repaint();
        return;
    }

    if (myPanel.DraggedMarker != null)
    {
        myPanel.DraggedMarker.UpdatePosition(XFromMouse(e.getX())-0.5-xOff,YFromMouse(e.getY())-0.5-yOff,DimNr);
    }
    else if (! myPanel.ROIstarted && ! LineROIStarted)   // Drags the image around
    {
        //boolean wasmoved=false;
        //otherCanvas1.dadd += e.getX() - xprev;
        //wasmoved |= otherCanvas1.LimitPosition(getBounds().width);
        //otherCanvas2.dadd += e.getY() - yprev;
        //wasmoved |= otherCanvas2.LimitPosition(getBounds().height);

        if (ImgDragStarted)
        {
            boolean wasmoved=false;
            otherCanvas1.dadd += e.getX() - ximgdrag;
            wasmoved |= otherCanvas1.LimitPosition(getBounds().width);
            otherCanvas2.dadd += e.getY() - yimgdrag;
            wasmoved |= otherCanvas2.LimitPosition(getBounds().height);
            ximgdrag = e.getX();yimgdrag = e.getY();
            repaint();
            return;
        }
        else
        {
            xprev = e.getX();yprev = e.getY();
        }

    }
    else
    {
        if (myPanel.ROIstarted)
        {
            otherCanvas1.ROIe = (int) XFromMouse(e.getX());
            otherCanvas2.ROIe = (int) YFromMouse(e.getY());      
        }
        if (LineROIStarted)
        {
            otherCanvas1.LROIe = (int) XFromMouse(e.getX());
            otherCanvas2.LROIe = (int) YFromMouse(e.getY());      
        }
    }
    repaint();
    updateothers(xprev,yprev);
    //updateothers(xprev-MouseFromX(xOff),yprev-MouseFromY(yOff));
    label.CoordsChanged();  
}

public void mouseMoved(MouseEvent e) {
        if (LineROIStarted)
        {
            otherCanvas1.LROIe = (int) XFromMouse(e.getX());
            otherCanvas2.LROIe = (int) YFromMouse(e.getY());
            repaint();
        }
}
// key press events
public void keyTyped(KeyEvent e) {
}

public void RedrawAll() { // A soft version of UpdateAll. No images have to be generated, just reposition
    repaint();
    otherCanvas1.repaint();
    otherCanvas2.repaint();
    return ;
}

public void UpdateAllNoCoord() {
    pickImage();
    repaint();
    otherCanvas1.pickImage();
    otherCanvas1.repaint();
    otherCanvas2.pickImage();
    otherCanvas2.repaint(); 
    return ;
}

public void UpdateAll() {
    UpdateAllNoCoord();
    label.CoordsChanged();
}

public void UpdateAllPanels() {
    if (!(applet instanceof View5D))
       ((View5D_) applet).UpdatePanels();   // commented out for now, since the document base is unknown for non-applets
    else
       ((View5D) applet).UpdatePanels();   // commented out for now, since the document base is unknown for non-applets
    label.CoordsChanged();
}

public void keyPressed(KeyEvent e) {
    char myChar = e.getKeyChar();

    if(KeyEvent.VK_PAGE_UP == e.getKeyCode())  
        {if (e.isShiftDown())
            myChar = ',';           // move along time direction
        else
            myChar = '(';
        }
    
    if(KeyEvent.VK_PAGE_DOWN == e.getKeyCode())
    {
        if (e.isShiftDown())
            myChar = '.';           // move along time direction
        else
            myChar = ')';
    }

    
    int elem=my3ddata.ActiveElement,t=my3ddata.ActiveTime;

    ImageCanvas PreferredCanvas=null;
    int advance=1;
    
    if(KeyEvent.VK_DOWN == e.getKeyCode())
	{
    	advance=1;
    	PreferredCanvas=otherCanvas2;
	}
    if(KeyEvent.VK_UP == e.getKeyCode())
	{
    	advance=-1;
    	PreferredCanvas=otherCanvas2;
	}
    if(KeyEvent.VK_RIGHT == e.getKeyCode())
	{
    	advance=1;
    	PreferredCanvas=otherCanvas1;
	}
    if(KeyEvent.VK_LEFT == e.getKeyCode())
	{
    	advance=-1;
    	PreferredCanvas=otherCanvas1;
	}

    if (PreferredCanvas != null)
    {
    if (e.isShiftDown())
	{
    	int emin=0,emax=my3ddata.Elements-1,pe=my3ddata.ActiveElement;
    	if (my3ddata.TrackDirection != 4)
  	  		{emin=pe;emax=pe;}
    	else
  	  		{emin=0;emax=my3ddata.Elements-1;}
        for (pe=emin;pe<=emax;pe++)
        {
    	my3ddata.ElementAt(pe).DisplayOffset[PreferredCanvas.DimNr]+=advance; 
        my3ddata.InvalidateProjs(pe,t); // only invalidate this element and this time
		}
    }
    else if (e.isControlDown())
    	  if (my3ddata.TrackDirection == 4)  // this is time
    		for (;t<my3ddata.Times;t++)
    		{my3ddata.ElementAt(elem,t).DisplayOffset[PreferredCanvas.DimNr]+=advance; 
    		my3ddata.InvalidateProjs(elem,t);} // only invalidate this element and this time
    	  else
    		for (;elem<my3ddata.Elements;elem++)
    		{my3ddata.ElementAt(elem,t).DisplayOffset[PreferredCanvas.DimNr]+=advance; 
    		my3ddata.InvalidateProjs(elem,t);} // only invalidate this element and this time
    	else 
    		{
    		PreferredCanvas.PositionValue+=advance;
    		if (PreferredCanvas.PositionValue >= PreferredCanvas.MaxPos-1)
    			PreferredCanvas.PositionValue = PreferredCanvas.MaxPos-1;
    		if (PreferredCanvas.PositionValue <= 0)
    			PreferredCanvas.PositionValue = 0;
    		}
    }
    else
    	ProcessKey(myChar);
    if (myChar != '?')
    	UpdateAll();
    return;
}

void SpawnHistogram(boolean forceHistogram) 
{
       // First estimate useful image sizes
        if (my3ddata.DataToHistogram != null)  // This seems to be a histogram, so it can only be applied
        {
            // System.out.println("Here am I\n");
            my3ddata.ApplyHistSelection();
            if (myPanel.DataPanel != null)
                myPanel.DataPanel.c1.UpdateAll();
        }
        else // this means a histogram has to be generated, not applied
        {
           if (my3ddata.MyHistogram == null || forceHistogram)
            {
            int MaxSize = 128;
            double HRangeX=my3ddata.GetScaledRange(my3ddata.HistoX);
            if (HRangeX <= 0) 
            {
                System.out.println("No coordinate selected as X histogram coordinate");
                return;
            }
            int HBinsX = MaxSize;
            double[] Scales = new double[5];
            for (int j=0;j<5;j++) Scales[j]=1.0;                
            double[] Offsets = new double[5];
            for (int j=0;j<5;j++) Offsets[j]=0.0;
            // double ScaleV=1.0,OffsetV=0.0;
            Scales[0] = HRangeX/(HBinsX-1.0);
            if (HRangeX > 50)
                {
                    Scales[0] = ((int) ((HRangeX-1)/MaxSize) + 1);
                    HBinsX = (int) (HRangeX / Scales[0]);
                    System.out.println("X Histscale : "+ HBinsX+ ", " + Scales[0]+"\n");
                }
            double HRangeY=1,HRangeZ=1;
                
            int HBinsY = 1, HBinsZ = 1;
            Offsets[0] = my3ddata.GetScaledMincs(my3ddata.HistoX);
            if (my3ddata.HistoY >=0)
            {
                HRangeY=my3ddata.GetScaledRange(my3ddata.HistoY);
                if (HRangeY <= 0) 
                {
                    System.out.println("No coordinate selected as Y histogram coordinate");
                    return;
                }
                if (HRangeY > 50)
                {
                    Scales[1] = ((int) ((HRangeY-1)/MaxSize) + 1);
                    HBinsY = (int) (HRangeY / Scales[1]);
                    System.out.println("Y Histscale : "+ HBinsY+ ", " + Scales[1]+"\n");
                }
                else
                {
                    HBinsY = MaxSize; Scales[1] = HRangeY / (HBinsY-1.0);
                    System.out.println("::: Y Histscale : "+ HBinsY+ ", "+ HRangeY + ", " + Scales[1]+"\n");
                }
                Offsets[1] = my3ddata.GetScaledMincs(my3ddata.HistoY);
            }
            if (my3ddata.HistoZ >=0)
            {
                HRangeZ=my3ddata.GetScaledRange(my3ddata.HistoZ);
                if (HRangeZ <= 0) 
                {
                    System.out.println("No coordinate selected as Z histogram coordinate");
                    return;
                }
                if (HRangeZ > 50)
                {
                    Scales[2] = ((int) ((HRangeZ-1)/MaxSize) + 1);
                    HBinsZ = (int) (HRangeZ / Scales[2]);
                }
                else
                {
                    // ScaleZ = ((int) ((HSizeZ-1)/MaxSize) + 1);HSizeZ = (int) (HSizeZ / ScaleZ);
                    HBinsZ = MaxSize;Scales[2] = HRangeZ / (HBinsZ-1.0);
                }
                Offsets[2] = my3ddata.GetScaledMincs(my3ddata.HistoZ);
            }
        
            My3DData Histogram = new My3DData(applet,HBinsX,HBinsY,HBinsZ,
                                      1,1, // One element, one timestep
                                      -1,-1,-1,  // RGB
                                      0,-1,-1, // histogram of histogram ?
                                      AnElement.IntegerType,4,31,
                                      Scales,Offsets,
                                      1.0,0.0,my3ddata.GetAxisNames(),my3ddata.GetAxisUnits());  // Four Bytes, 31 bits
        
            Histogram.TakeDataToHistogram(my3ddata);
            Histogram.ComputeHistogram();
            Histogram.ToggleModel(5);  // mark as red glow
            Histogram.ToggleOverlayDispl(1); // Make element visible in multicolor mode
            AlternateViewer xx2=new AlternateViewer(applet);
            xx2.Assign3DData(applet,myPanel,Histogram);
            if (my3ddata.MyHistogram == null)
                my3ddata.MyHistogram = Histogram;  // otherwise forget it as a single window
            my3ddata.DataToHistogram = null; // were was this set to some value??
            // xx2.invalidate();
            // xx2.repaint();
            // xx2.setEnabled(true);
            // What to do to make this window visible without a resize by the user???
            }
            else  // 'h' was pressed in data (not in histogram)
            {
                if (my3ddata.MyHistogram.Elements==1)
                    my3ddata.MyHistogram.colormode=true;  // set to multicolor at the second histogram
                my3ddata.MyHistogram.CloneLastElements();
                my3ddata.MyHistogram.TakeDataToHistogram(my3ddata);  // Necessary to connect this element to HistogramX ...
                my3ddata.MyHistogram.ComputeHistogram();
            }
        }
        // my3ddata.MyHistogram.UpdateAll();
        return ;
 }

 public void ExportValues() {
     PlotWindow myplot = new PlotWindow("View5D Plot",XAxisTitle,YAxisTitle,AxisData,LineData);
     myplot.draw();
     // return myplot;
   }


public void ProcessKey(char myChar) {
    switch (myChar) {
    case ' ':
        ImgDragStarted = true;
	return;
    case 'D':
        my3ddata.DeleteActElement();
	UpdateAllPanels();
	return;
    case 'f':  // upcast datatype to float
        my3ddata.CloneFloat();
	UpdateAllPanels();
        return;
    case 'F':  // upcast datatype to short, in this case thresholds will be applied
        my3ddata.CloneShort();
	UpdateAllPanels();
        return;
    case '+':
        my3ddata.AddMarkedElement(); // Adds the gate element to the active element
	UpdateAllPanels();
	return;
    case '_':
        my3ddata.AdjustOffsetToROIMean(); // Subtracts the gate element from the active element
	UpdateAllPanels();
	return;
    case '-':
        my3ddata.SubMarkedElement(); // Subtracts the gate element from the active element
	UpdateAllPanels();
	return;
    case '*':
        my3ddata.MulMarkedElement(); // Multiplies the gate element with the active element
	UpdateAllPanels();
	return;
    case '/':
        my3ddata.DivMarkedElement(); // Multiplies the gate element with the active element
	UpdateAllPanels();
	return;
    case 'e':  // advance one element cyclicly
    	myPanel.RememberOffset();
    	my3ddata.advanceElement(1);
    	myPanel.AdjustOffset();
    	UpdateAll();
	return;
    case 'E':  // advance one element cyclicly
    	myPanel.RememberOffset();
    	my3ddata.advanceElement(-1);
    	myPanel.AdjustOffset();
    	UpdateAll();
	return;
    case 't':  // automatic threshold adjustment
	my3ddata.AdjustThresh(false);
	UpdateAll();
	return ;
    case 'T':  // automatic threshold adjustment
	my3ddata.AdjustThresh(true);
	UpdateAll();
	return ;
    case 'n':  // 
        my3ddata.MarkerDialog();
	// my3ddata.ToggleConnection(-1);
	UpdateAll();
	return;
    case 'N':  // Pops up a "Units" dialog
	my3ddata.AxesUnitsDialog();
        my3ddata.InvalidateProjs(-1);  // all projections are invalid
	label.CoordsChanged();
	break;
    case 'r':  // Choose Red colormap
	my3ddata.ToggleModel(1);
	my3ddata.ToggleOverlayDispl(1);
	//my3ddata.MarkChannel(0);
	UpdateAll();
	return ;
    case 'R':  // mark red channel
	my3ddata.ToggleModel(5);
	my3ddata.ToggleOverlayDispl(1);
	//my3ddata.ClearChannel(0);
	UpdateAll();
	return ;
    case 'g':  // mark green channel
	my3ddata.ToggleModel(2);
	my3ddata.ToggleOverlayDispl(1);
	//my3ddata.MarkChannel(1);
	UpdateAll();
	return ;
    case 'G':  // mark green channel
	my3ddata.ToggleModel(0);
	my3ddata.ToggleOverlayDispl(1);
	//my3ddata.ClearChannel(1);
	UpdateAll();
	return;
    case 'b':  // mark blue channel
	my3ddata.ToggleModel(3);
	my3ddata.ToggleOverlayDispl(1);
	//my3ddata.MarkChannel(2);
	UpdateAll();
	return;
    case 'B':  // mark blue channel
	my3ddata.ToggleModel(10);
	my3ddata.ToggleOverlayDispl(1);
	//my3ddata.ClearChannel(2);
	UpdateAll();
	return;
    case 'v':  // in/exclude channel from color display
	my3ddata.ToggleOverlayDispl(-1);
	UpdateAll();
	return;
    case 'V':  // in/exclude channel from color display
	my3ddata.ToggleMulDispl(-1);
	UpdateAll();
	return;
    case 'k':  // Creates a new Marker List and inserts a point
    	if (my3ddata.NumMarkerLists() > 0 && my3ddata.GetActiveMarker() != null)
    		my3ddata.NewMarkerList();
        my3ddata.SetMarker(label.px,label.py,label.pz);
	// my3ddata.AddPoint(label.px,label.py,label.pz);
	UpdateAll();
	return;
    case '\\':  // '\' Creates two new marker lists which are linked to the current list (e.g. for Cell Division)
    	my3ddata.DevideMarkerList(label.px,label.py,label.pz);
	// my3ddata.AddPoint(label.px,label.py,label.pz);
	UpdateAll();
	return;
    case 'K':  // Set marker for Multiple spectral plots
        my3ddata.RemoveMarkerList();
	UpdateAll();
	return;
    case '&':  // remove this active point
	my3ddata.TagMarker();  // Toggles Marker Tag
	System.out.println("Error Tagged Component setValue called\n"); 
	UpdateAll();
	return;
    case 'm':  // Set marker
        my3ddata.SetMarker(label.px,label.py,label.pz);
	if (my3ddata.FocusDispToMarker)
		{myPanel.setPositions(my3ddata.GetActiveMarker());CalcPrev();}
	if (my3ddata.Advance)
		myPanel.AdvancePos();
	// System.out.println("should have advanced" + my3ddata.Advance); 
	// my3ddata.AddPoint(label.px,label.py,label.pz);
	UpdateAll();
	return;
    case 'M':  // remove this active point
	my3ddata.RemovePoint();  // If possible
	if (my3ddata.FocusDispToMarker)
		{myPanel.setPositions(my3ddata.GetActiveMarker());CalcPrev();}
	UpdateAll();
	return;
    case '$':  // time to say goodbye
        // java.lang.System.exit(0);   // exit the application by ending the java virtual mashine
        // close the main window and free as much memory as possible
        my3ddata.cleanup();
        applet.removeAll();
        otherCanvas1.removeNotify();
        otherCanvas2.removeNotify();
        this.removeNotify();
        System.gc();
	if (!(applet instanceof View5D))  // This is ImageJ specific
            ((View5D_) applet).dispose();
        else
        {
            ((View5D) applet).stop();            
            ((View5D) applet).destroy();
        }
        return;
   case 'Q':  // remove all point to the end of the list
	my3ddata.RemoveTrailingPoints();  // If possible
	UpdateAll();
	return;
    case '0':  // Advance marker
    myPanel.RememberOffset();
	my3ddata.AdvancePoint(1);
    myPanel.AdjustOffset();
	if (my3ddata.FocusDispToMarker)
		{myPanel.setPositions(my3ddata.GetActiveMarker());CalcPrev();} // Update the crosshair
	UpdateAll();
	return;
    case '9':  // Devance Marker
    myPanel.RememberOffset();
	my3ddata.AdvancePoint(-1);
    myPanel.AdjustOffset();
	if (my3ddata.FocusDispToMarker)
		{myPanel.setPositions(my3ddata.GetActiveMarker());CalcPrev();}
	UpdateAll();
	return;
    case 'j':  // Set marker for Multiple spectral plots
	my3ddata.AdvanceMarkerList(1);
	if (my3ddata.FocusDispToMarker)
		{myPanel.setPositions(my3ddata.GetActiveMarker());CalcPrev();}
	UpdateAll();
		
	return;
    case 'J':  
	my3ddata.AdvanceMarkerList(-1);
	if (my3ddata.FocusDispToMarker)
		{myPanel.setPositions(my3ddata.GetActiveMarker());CalcPrev();}
	UpdateAll();
	return;
    case 'w':  
	my3ddata.ToggleMarkerListColor(1);
	UpdateAll();
	return;
    case 'W':  
	my3ddata.AutoTrack();
	UpdateAll();
	return;
    case '|': 
    	my3ddata.AlignOffsetsToTrack();
    	UpdateAll();
    	return;
    case '{': 
    	my3ddata.ResetOffsets();
    	UpdateAll();
    	return;
    case '}': 
    	my3ddata.MarkerListDialog();
    	UpdateAll();
    	return;
    case '@':  
    	AspectLocked.setState(! AspectLocked.getState());
    	return;
    case '#':  
	my3ddata.SubtractTrackedSpot();
        my3ddata.InvalidateProjs(-1);  // all projections are invalid
        my3ddata.InvalidateSlices();
	UpdateAll();
	return;
    case 's': 
        AlternateViewer xx=new AlternateViewer(applet);  // clone the data and open a new viewer
        My3DData nd=new My3DData(my3ddata);
        xx.Assign3DData(applet, null, nd);
	UpdateAll();
        return;
    case 'P':
	my3ddata.ToggleProj(DimNr,false);
	label.CoordsChanged();  
	UpdateAll();
        return ;
    case 'p':
	my3ddata.ToggleProj(DimNr,true);
	UpdateAll();
        return ;
    case '^':
	my3ddata.ActElement().AdvanceReadMode();
	my3ddata.InvalidateSlices();
	my3ddata.InvalidateProjs(-1);
	UpdateAll();
        return ;
    case 'S':
        if (! myPanel.ROIstarted && ! LineROIStarted)   // otherwise the user has to finish the ROI first
        {
            my3ddata.ToggleSquareROIs();
            my3ddata.InvalidateProjs(-1);  // all projections are invalid
            UpdateAll();  // To display current ROIs
        }
        return;
    case 'x':  // mark active element for x-coordinate of histogram
        my3ddata.MarkAsHistoDim(0);
	label.CoordsChanged();
        return;
    case 'y':  // mark active element for x-coordinate of histogram
        my3ddata.MarkAsHistoDim(1);
	label.CoordsChanged();
        return;
    case 'z':  // mark active element for x-coordinate of histogram
        my3ddata.MarkAsHistoDim(2);
	label.CoordsChanged();
        return;
    case 'Z':  // Zoom in to match square ROI
        double scalex= getBounds().width/(1.5+otherCanvas1.ROIe-otherCanvas1.ROIs);
        double scaley= getBounds().height/(1.5+otherCanvas2.ROIe-otherCanvas2.ROIs);
        if (AspectLocked.getState())
            if (scalex > scaley)
                scalex = scaley;
            else
                scaley = scalex;
        otherCanvas1.scale = scalex;
        otherCanvas2.scale = scaley;
        otherCanvas1.dadd -= MouseFromX(otherCanvas1.ROIs-0.5);
        otherCanvas2.dadd -= MouseFromY(otherCanvas2.ROIs-0.5);
	UpdateAll();
        return;
    case 'U':  // set Gating-element to this
        my3ddata.toggleGate(-1);   // will force the thresholds to be copied if necessary
	UpdateAll();
        return;
    case 'u':  // set Gating-element to this
        my3ddata.setGate();  // toggles. Will force the thresholds to be copied if necessary
	UpdateAll();
        return;
    case 'H':  // apply Histogram ROI selection to data
    case 'h':  // generate a Histogram
        SpawnHistogram(myChar == 'H');   // if 'H' the histogram will be forced, even if allready present
        UpdateAllPanels();
        //my3ddata.MyHistogram.UpdateAll();
        return;
    case 'C':
	my3ddata.ToggleColor();
	UpdateAll();
	return ;
    case 'c':
	my3ddata.ToggleModel(-1);
	UpdateAll();
	return ;
    case 'd':
	my3ddata.InvertCMap();
	my3ddata.ToggleModel(-1);
	my3ddata.InvertCMap();
	UpdateAll();
	return ;
    case 'o':   // in color mode, all will be set to the current state
	my3ddata.ToggleOvUn(-1);
	UpdateAll();
	return ;
    case 'O':
	my3ddata.ToggleLog(-1);
	UpdateAll();
	return ;
    case ',':  // moves along time direction
       	myPanel.RememberOffset();
        my3ddata.nextTime(1);
       	myPanel.AdjustOffset();
       	UpdateAll();
	return ;
    case '.':  // moves along time direction
       	myPanel.RememberOffset();
        my3ddata.nextTime(-1);
       	myPanel.AdjustOffset();
       	UpdateAll();
	return ;        
    case '(':   // moves into Z-direction
	if (PositionValue < MaxPos-1)
	    PositionValue++;
        UpdateAll();
	//pickImage();
	//re'paint();
	//updateothers(xprev,yprev);
	return ;
    case ')':
	if (PositionValue > 0)
	    PositionValue--;
	UpdateAll();
	// pickImage();
	// repaint();
	// updateothers(xprev,yprev);
	return ;
    case 'A':
    	
        int xp = getCrossHairX();   // pixel position of the crosshair
        int yp = getCrossHairY();
    	
        otherCanvas1.scale *= 1.25;
        otherCanvas2.scale *= 1.25;
        otherCanvas1.dadd += xp-getCrossHairX();
        otherCanvas2.dadd += yp-getCrossHairY();
        otherCanvas1.LimitPosition(getBounds().width);
        otherCanvas2.LimitPosition(getBounds().height);
        if (otherCanvas2.AspectLocked.getState() || otherCanvas1.AspectLocked.getState())
        {
            double zp = getCrossHairZ();
            scale *= 1.25;
            dadd += zp-getCrossHairZ();
            LimitPosition(getBounds().height);
        }

        RedrawAll();
        label.CoordsChanged(); 
        return ;
    case 'a':
        xp = getCrossHairX();   // pixel position of the crosshair
        yp = getCrossHairY();
    	
        otherCanvas1.scale /= 1.25;
        otherCanvas2.scale /= 1.25;
        otherCanvas1.dadd += xp-getCrossHairX();
        otherCanvas2.dadd += yp-getCrossHairY();
        otherCanvas1.LimitPosition(getBounds().width);
        otherCanvas2.LimitPosition(getBounds().height);
        if (otherCanvas2.AspectLocked.getState() || otherCanvas1.AspectLocked.getState())
        {
            double zp = getCrossHairZ();
            scale /= 1.25;
            dadd += zp-getCrossHairZ();
            LimitPosition(getBounds().height);
        }

        RedrawAll();
        label.CoordsChanged(); 
        return ;
	
    case '>':
        if (! otherCanvas1.AspectLocked.getState() && ! otherCanvas2.AspectLocked.getState())
        {
	dadd -= 0.125*scale*PositionValue;
	scale *= 1.25;
	RedrawAll();
        }
	return ;
    case '<':
        if (! otherCanvas1.AspectLocked.getState() && ! otherCanvas2.AspectLocked.getState())
        {
	if (scale > 1.0)
	    {
		scale /= 1.125;
		dadd += 0.125*scale*PositionValue;
                RedrawAll();
	    }
        }
	return ;
    case 'q':
	DispPlot = ! DispPlot;  // Toggle plot display
	repaint();
	return ;
    
    //case ':':
	//xadd += 5;
	//repaint();
	//return ;
    //case ';':
    //	xadd -= 5;
	//repaint();
	//return ;
    case '!':   // transfers the colormap threshold to data threshold
	// my3ddata.addLThresh(0.02);
	my3ddata.CThreshToValThresh(-1,0.0,1.0);
	UpdateAll();
	return ;
    case '1':
        if (my3ddata.GateActive && (my3ddata.GateElem == my3ddata.GateElem))
            {
            my3ddata.addLThresh(0.02);
            }
        else
            my3ddata.adjustColorMapLThresh(0.02);
	UpdateAll();
	return ;
    case '2':
        if (my3ddata.GateActive && (my3ddata.GateElem == my3ddata.GateElem))
            {
            my3ddata.addLThresh(-0.02);
            }
        else
            my3ddata.adjustColorMapLThresh(-0.02);
 	UpdateAll();
	return ;
    case '3':
        if (my3ddata.GateActive && (my3ddata.GateElem == my3ddata.GateElem))
            {
            my3ddata.addUThresh(0.02);
            }
        else
            my3ddata.adjustColorMapUThresh(0.02);
	UpdateAll();
	return ;
    case '4':
        if (my3ddata.GateActive && (my3ddata.GateElem == my3ddata.GateElem))
            {
            my3ddata.addUThresh(-0.02);
            }
        else
            my3ddata.adjustColorMapUThresh(-0.02);
        UpdateAll();
	return ;
    case '5':
        if (my3ddata.GateActive && (my3ddata.GateElem == my3ddata.GateElem))
            {
            my3ddata.addLThresh(0.002);
            }
        else
            my3ddata.adjustColorMapLThresh(0.002);
	UpdateAll();
	return ;
    case '6':
        if (my3ddata.GateActive && (my3ddata.GateElem == my3ddata.GateElem))
            {
            my3ddata.addLThresh(-0.002);
            }
        else
            my3ddata.adjustColorMapLThresh(-0.002);
	UpdateAll();
	return ;
    case '7':
        if (my3ddata.GateActive && (my3ddata.GateElem == my3ddata.GateElem))
            {
            my3ddata.addUThresh(0.002);
            }
        else
            my3ddata.adjustColorMapUThresh(0.002);
	UpdateAll();
	return ;
    case '8':
        if (my3ddata.GateActive && (my3ddata.GateElem == my3ddata.GateElem))
            {
            my3ddata.addUThresh(-0.002);
            }
        else
            my3ddata.adjustColorMapUThresh(-0.002);
	UpdateAll();
	return ;
    case 'i':
	//my3ddata.initThresh();
	InitScaling();
	CalcPrev();
	UpdateAll();
	return ;
    case 'I':
	my3ddata.initGlobalThresh();
	InitScaling();
	CalcPrev();
	UpdateAll();
	return ;
    case 'X':  // export to ImageJ
	if (!(applet instanceof View5D))
            if (DispPlot)
                ExportValues();   // a new plot window in ImageJ will be generated
            else
                my3ddata.Export(DimNr, (int) PositionValue);   // a new stack in ImageJ will be generated
	return ;
    case 'Y':  // generate ROI Mask
        my3ddata.GenerateMask(DimNr);   // a new element will be generated
	UpdateAll();  // To display mask
	return ;
    case 'l':
	if (!(applet instanceof View5D))
	   ((View5D_) applet).LoadImg(0);  
	else
	   my3ddata.Load(my3ddata.PrevType,my3ddata.PrevBytes,my3ddata.PrevBits,((View5D) applet).filename,((View5D) applet));   // commented out for now, since the document base is unknown for non-applets
        UpdateAllPanels();
	UpdateAll();  // To display mask
	return;
    case 'L':
	my3ddata.LoadMarkers();  
        UpdateAllPanels();
	return;
    
    case '?':
        label.Help();
        return ;
        }
}

public void keyReleased(KeyEvent e) {
}

}
