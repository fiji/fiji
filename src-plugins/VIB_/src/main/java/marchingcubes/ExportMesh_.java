/* -*- mode: java; c-basic-offset: 8; indent-tabs-mode: t; tab-width: 8 -*- */

package marchingcubes;

/* Put together from existing code in the repository, this plugin just
 * exports a Wavefront .obj file from an ImagePlus using
 * MCTriangulator.  This is useful so you can import the triangulated
 * image into Blender, for example. */

import ij.ImagePlus;
import ij.IJ;
import ij.WindowManager;
import ij.gui.GenericDialog;
import ij.io.SaveDialog;
import ij.io.FileInfo;
import ij.plugin.PlugIn;
import ij.measure.Calibration;
import java.util.List;
import java.util.ArrayList;
import java.util.Hashtable;
import java.util.Iterator;
import java.io.File;
import java.io.PrintStream;
import java.io.IOException;
import ij3d.ColorTable;
import javax.vecmath.Point3f;
import javax.vecmath.Vector3f;

public class ExportMesh_ implements PlugIn {

	public void exportToMesh( ImagePlus imagePlus, int minimumValue, int resamplingFactor, boolean [] channels, String outputFilename ) {

		MCTriangulator triangulator = new MCTriangulator();
		
		List mesh = triangulator.getTriangles(
			imagePlus, minimumValue, channels, resamplingFactor);

		if( (mesh.size() % 3) != 0 ) {
			IJ.error("There weren't a multiple of 3 entries in the mesh List");
			return;
		}

		Hashtable pointToIndex = new Hashtable();
		ArrayList<Point3f> uniquePoints = new ArrayList<Point3f>();
		
		int i = 0;
		for( Iterator iter = mesh.iterator(); iter.hasNext(); ) {
			
			Point3f p = (Point3f)iter.next();

			Integer i_in_table = (Integer)pointToIndex.get(p);
			
			if( null == i_in_table ) {
				pointToIndex.put(p,new Integer(i));
				uniquePoints.add(p);
				++ i;
			}
		}

		try {
			
			PrintStream ps = new PrintStream(outputFilename);

			ps.println("# Almost the simplest possible Wavefront .obj file.");
			ps.println("# Generated by the ExportMesh_ plugin in ImageJ.");

			// First dump the vertices:

			for( Iterator iterator = uniquePoints.iterator();
			     iterator.hasNext(); ) {
				Point3f p = (Point3f)iterator.next();
				ps.println("v "+p.x+" "+p.y+" "+p.z);
			}			     

			ps.println("s 1");

			// Now dump the triangles:

			for( Iterator iter = mesh.iterator(); iter.hasNext(); ) {
			
				Point3f p1 = (Point3f)iter.next();
				Point3f p2 = (Point3f)iter.next();
				Point3f p3 = (Point3f)iter.next();
				
				int i_in_table_1 = ((Integer)pointToIndex.get(p1)).intValue()+1;
				int i_in_table_2 = ((Integer)pointToIndex.get(p2)).intValue()+1;
				int i_in_table_3 = ((Integer)pointToIndex.get(p3)).intValue()+1;
				
				ps.println("f "+i_in_table_1+" "+i_in_table_2+" "+i_in_table_3);

			}

		} catch( IOException e ) {
			IJ.error("Saving to '"+outputFilename+"' failed: "+e);
			return;
		}
	}
	
	public void run(String arguments) {
		
		int[] wList = WindowManager.getIDList();
		if (wList==null) {
			IJ.error("ExportMesh: No images are open.");
			return;
		}
		if( wList.length < 1 ) {
			IJ.error("ExportMesh: No images are open.");
			return;
		}
		
		String[] titles = new String[wList.length];
		for (int i=0; i<wList.length; i++) {
			ImagePlus imp = WindowManager.getImage(wList[i]);
			titles[i] = imp!=null?imp.getTitle():"";
		}
		
		GenericDialog gd = new GenericDialog("Triangulate");
		gd.addChoice("Stack:", titles, titles[0]);
		gd.addNumericField("Threshold", 50, 0);
		gd.addNumericField("Resampling factor", 2, 0);
		gd.addMessage("Channels");
		gd.addCheckboxGroup(1, 3, 
				    new String[] {"red", "green", "blue"}, 
				    new boolean[]{true, true, true});
		
		gd.showDialog();
		if(gd.wasCanceled())
			return;
		
		int index = gd.getNextChoiceIndex();
		
		ImagePlus imp = WindowManager.getImage(wList[index]);
		int threshold = (int)gd.getNextNumber();
		int factor = (int)gd.getNextNumber();
		boolean[] channels = new boolean[] {gd.getNextBoolean(), 
						    gd.getNextBoolean(), 
						    gd.getNextBoolean()};
		
		if( imp == null ) {
			IJ.error( "Must select a currently open image" );
			return;
		}
		
		/* This information is just thrown away? */
		
		Vector3f tr = new Vector3f();
		if(imp != null) {
			Calibration c = imp.getCalibration();
			tr.x = (float)(-imp.getWidth() * c.pixelWidth/2f);
			tr.y = (float)(-imp.getHeight() * c.pixelHeight/2f); 
			tr.z = (float)(-imp.getStackSize() * c.pixelDepth/2f);
		}
		
		/* Choose an obj filename to save to.... */
		
		FileInfo info = imp.getOriginalFileInfo();
		SaveDialog sd;
		
		if( info == null ) {
			
			sd = new SaveDialog("Save mesh as...",
					    "mesh.obj",
					    ".obj");
			
		} else {
			
			String fileName = info.fileName;
			String directory = info.directory;
			
			String suggestedSaveFilename;
			
			suggestedSaveFilename = fileName+".obj";
			
			sd = new SaveDialog("Save mesh as...",
					    directory,
					    suggestedSaveFilename,
					    ".obj");
		}
		
		String savePath;
		if(sd.getFileName()==null) {
			// System.out.println("no savePath found");
			return;
		} else {
			savePath = sd.getDirectory()+sd.getFileName();
			// System.out.println("found savePath: "+savePath);
		}
		
		File file = new File(savePath);
		if ((file!=null)&&file.exists()) {
			if (!IJ.showMessageWithCancel(
				    "Save traces file...", "The file "+
				    savePath+" already exists.\n"+
				    "Do you want to replace it?"))
				return;
		}
		
		IJ.showStatus("Saving label annotations to "+savePath);
		
		exportToMesh( imp, threshold, factor, channels, savePath );
	}
}
